{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NCronJob \u00b6 A Job Scheduler sitting on top of IHostedService in dotnet. Often times one finds themself between the simplicity of the BackgroundService / IHostedService and the complexity of a full-blown Hangfire or Quartz scheduler. This library aims to fill that gap by providing a simple and easy to use job scheduler that can be used in any dotnet application and feels \u201cnative\u201d. So no need for setting up a database, just schedule your stuff right away! The library gives you two ways of scheduling jobs: Instant jobs - just run a job right away (or with a small delay; or with a given date and time) Cron jobs - schedule a job using a cron expression This library is possible because of these wonderful people: If you want to support this project, you can: Leave a star \u2b50\ufe0f If you find issues, report them to us: https://github.com/linkdotnet/NCronJob/issues If you have a feature request, let us know: https://github.com/linkdotnet/NCronJob/issues","title":"NCronJob"},{"location":"#ncronjob","text":"A Job Scheduler sitting on top of IHostedService in dotnet. Often times one finds themself between the simplicity of the BackgroundService / IHostedService and the complexity of a full-blown Hangfire or Quartz scheduler. This library aims to fill that gap by providing a simple and easy to use job scheduler that can be used in any dotnet application and feels \u201cnative\u201d. So no need for setting up a database, just schedule your stuff right away! The library gives you two ways of scheduling jobs: Instant jobs - just run a job right away (or with a small delay; or with a given date and time) Cron jobs - schedule a job using a cron expression This library is possible because of these wonderful people: If you want to support this project, you can: Leave a star \u2b50\ufe0f If you find issues, report them to us: https://github.com/linkdotnet/NCronJob/issues If you have a feature request, let us know: https://github.com/linkdotnet/NCronJob/issues","title":"NCronJob"},{"location":"getting-started/","text":"Getting Started \u00b6 Using NCronJob is simple and easy. Just follow the steps below to get started. 1. Install the package \u00b6 Install the latest stable version of the package via NuGet: dotnet add package LinkDotNet.NCronJob Alternatively add the package reference to your .csproj file: <PackageReference Include= \"LinkDotNet.NCronJob\" Version= \"2.4.6\" /> 2. Create a job \u00b6 NCronJob offers a single way of defining jobs: by implementing the IJob interface with a single RunAsync method: public class PrintHelloWorld : IJob { private readonly ILogger < PrintHelloWorld > logger ; public PrintHelloWorld ( ILogger < PrintHelloWorld > logger ) { this . logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( \"Hello World\" ); logger . LogInformation ( \"Parameter: {Parameter}\" , context . Parameter ); return Task . CompletedTask ; } } 3. Register the service and the job \u00b6 The NCronJob library provides one easy entry point for all its magic, the AddNCronJob extension method on top of the IServiceCollection interface. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); })); }); Now your PrintHelloWorld job will run every minute and log \u201cHello World\u201d to the console. And that is all! Too complicated? \u00b6 We also over a \u201cMinimal API\u201d that allows you to define jobs similiar to the Minimal API for Controllers. builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); The job will be defined \u201cinline\u201d and is capable of resolving services from the DI container. You can read more about this in the section Minimal API .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Using NCronJob is simple and easy. Just follow the steps below to get started.","title":"Getting Started"},{"location":"getting-started/#1-install-the-package","text":"Install the latest stable version of the package via NuGet: dotnet add package LinkDotNet.NCronJob Alternatively add the package reference to your .csproj file: <PackageReference Include= \"LinkDotNet.NCronJob\" Version= \"2.4.6\" />","title":"1. Install the package"},{"location":"getting-started/#2-create-a-job","text":"NCronJob offers a single way of defining jobs: by implementing the IJob interface with a single RunAsync method: public class PrintHelloWorld : IJob { private readonly ILogger < PrintHelloWorld > logger ; public PrintHelloWorld ( ILogger < PrintHelloWorld > logger ) { this . logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( \"Hello World\" ); logger . LogInformation ( \"Parameter: {Parameter}\" , context . Parameter ); return Task . CompletedTask ; } }","title":"2. Create a job"},{"location":"getting-started/#3-register-the-service-and-the-job","text":"The NCronJob library provides one easy entry point for all its magic, the AddNCronJob extension method on top of the IServiceCollection interface. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); })); }); Now your PrintHelloWorld job will run every minute and log \u201cHello World\u201d to the console. And that is all!","title":"3. Register the service and the job"},{"location":"getting-started/#too-complicated","text":"We also over a \u201cMinimal API\u201d that allows you to define jobs similiar to the Minimal API for Controllers. builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); The job will be defined \u201cinline\u201d and is capable of resolving services from the DI container. You can read more about this in the section Minimal API .","title":"Too complicated?"},{"location":"advanced/global-concurrency/","text":"Global Concurrency \u00b6 NCronJob utilisies a priority queue with a maximum amount of entries. That is, the queue will only hold and execute a maximum amount of jobs at any given time. This is to prevent the system from being overloaded with jobs. The Maxmimum \u00b6 The global maximum of concurrent jobs is calculated as: var maxDegreeOfParallelism = Environment . ProcessorCount * 4 ; If you have a CPU with 12 Cores (like a M2 Processor), the maximum amount of concurrent jobs will be 48. A CRON job is rescheduled after it has been executed. This means that the queue will always be filled with jobs that are ready to be executed. If that queue is full, no more jobs will be added to the queue until a job has been executed. A simple example: You have only one processor (therefore maximum 4 jobs executed at the same time) and a cron job that runs every minute. The job takes six minutes to complete. So after four minutes the queue is full, and no more jobs will be added to the queue. After the fifth minute, the queue is still full, and no more jobs will be added to the queue. After the sixth minute, the first job is removed from the queue, and the next job is added to the queue. Therefore it can happen that jobs are skipped and not executed. The same applies to the SupportsConcurrencyAttribute discussed in: Concurrency Control","title":"Global Concurrency"},{"location":"advanced/global-concurrency/#global-concurrency","text":"NCronJob utilisies a priority queue with a maximum amount of entries. That is, the queue will only hold and execute a maximum amount of jobs at any given time. This is to prevent the system from being overloaded with jobs.","title":"Global Concurrency"},{"location":"advanced/global-concurrency/#the-maxmimum","text":"The global maximum of concurrent jobs is calculated as: var maxDegreeOfParallelism = Environment . ProcessorCount * 4 ; If you have a CPU with 12 Cores (like a M2 Processor), the maximum amount of concurrent jobs will be 48. A CRON job is rescheduled after it has been executed. This means that the queue will always be filled with jobs that are ready to be executed. If that queue is full, no more jobs will be added to the queue until a job has been executed. A simple example: You have only one processor (therefore maximum 4 jobs executed at the same time) and a cron job that runs every minute. The job takes six minutes to complete. So after four minutes the queue is full, and no more jobs will be added to the queue. After the fifth minute, the queue is still full, and no more jobs will be added to the queue. After the sixth minute, the first job is removed from the queue, and the next job is added to the queue. Therefore it can happen that jobs are skipped and not executed. The same applies to the SupportsConcurrencyAttribute discussed in: Concurrency Control","title":"The Maxmimum"},{"location":"advanced/log-level/","text":"Controlling the log-level \u00b6 The NCronJob scheduler can be configured to log at a specific log level. { \"Logging\" : { \"LogLevel\" : { \"Default\" : \"Information\" , \"Microsoft.AspNetCore\" : \"Warning\" , \"LinkDotNet.NCronJob\" : \"Debug\"","title":"Controlling the log level"},{"location":"advanced/log-level/#controlling-the-log-level","text":"The NCronJob scheduler can be configured to log at a specific log level. { \"Logging\" : { \"LogLevel\" : { \"Default\" : \"Information\" , \"Microsoft.AspNetCore\" : \"Warning\" , \"LinkDotNet.NCronJob\" : \"Debug\"","title":"Controlling the log-level"},{"location":"features/concurrency-control/","text":"Concurrency Control \u00b6 Concurrency support allows multiple instances of the same job type to run simultaneously, controlled by the SupportsConcurrency attribute. This feature is crucial for efficiently managing jobs that are capable of running in parallel without interference. By default jobs are not executed concurrently if the SupportsConcurrency attribute is not set. How It Works \u00b6 The SupportsConcurrency attribute specifies the maximum degree of parallelism for job instances. This means you can define how many instances of a particular job can run concurrently, optimizing performance and resource utilization based on the nature of the job and the system capabilities. Using the SupportsConcurrency Attribute \u00b6 Here is an example of how to apply this attribute to a job: Example: Concurrency in Jobs \u00b6 [SupportsConcurrency(10)] public class ConcurrentJob : IJob { private readonly ILogger < ConcurrentJob > logger ; public ConcurrentJob ( ILogger < ConcurrentJob > logger ) { this . logger = logger ; } public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} is running.\" ); // Simulate some work by delaying await Task . Delay ( 5000 , token ); logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} has completed.\" ); } } Important Considerations \u00b6 Ensuring Job Idempotency \u00b6 When using concurrency, it\u2019s essential to ensure that each job instance is idempotent. This means that even if the job is executed multiple times concurrently or sequentially, the outcome and side effects should remain consistent, without unintended duplication or conflict. Resource Allocation Caution \u00b6 Jobs that are marked to support concurrency should be designed carefully to avoid contention over shared resources. This includes, but is not limited to, database connections, file handles, or any external systems. In scenarios where shared resources are unavoidable, proper synchronization mechanisms or concurrency control techniques, such as semaphores, mutexes, or transactional control, should be implemented to prevent race conditions and ensure data integrity.","title":"Concurrency control"},{"location":"features/concurrency-control/#concurrency-control","text":"Concurrency support allows multiple instances of the same job type to run simultaneously, controlled by the SupportsConcurrency attribute. This feature is crucial for efficiently managing jobs that are capable of running in parallel without interference. By default jobs are not executed concurrently if the SupportsConcurrency attribute is not set.","title":"Concurrency Control"},{"location":"features/concurrency-control/#how-it-works","text":"The SupportsConcurrency attribute specifies the maximum degree of parallelism for job instances. This means you can define how many instances of a particular job can run concurrently, optimizing performance and resource utilization based on the nature of the job and the system capabilities.","title":"How It Works"},{"location":"features/concurrency-control/#using-the-supportsconcurrency-attribute","text":"Here is an example of how to apply this attribute to a job:","title":"Using the SupportsConcurrency Attribute"},{"location":"features/concurrency-control/#example-concurrency-in-jobs","text":"[SupportsConcurrency(10)] public class ConcurrentJob : IJob { private readonly ILogger < ConcurrentJob > logger ; public ConcurrentJob ( ILogger < ConcurrentJob > logger ) { this . logger = logger ; } public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} is running.\" ); // Simulate some work by delaying await Task . Delay ( 5000 , token ); logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} has completed.\" ); } }","title":"Example: Concurrency in Jobs"},{"location":"features/concurrency-control/#important-considerations","text":"","title":"Important Considerations"},{"location":"features/concurrency-control/#ensuring-job-idempotency","text":"When using concurrency, it\u2019s essential to ensure that each job instance is idempotent. This means that even if the job is executed multiple times concurrently or sequentially, the outcome and side effects should remain consistent, without unintended duplication or conflict.","title":"Ensuring Job Idempotency"},{"location":"features/concurrency-control/#resource-allocation-caution","text":"Jobs that are marked to support concurrency should be designed carefully to avoid contention over shared resources. This includes, but is not limited to, database connections, file handles, or any external systems. In scenarios where shared resources are unavoidable, proper synchronization mechanisms or concurrency control techniques, such as semaphores, mutexes, or transactional control, should be implemented to prevent race conditions and ensure data integrity.","title":"Resource Allocation Caution"},{"location":"features/define-and-schedule-jobs/","text":"Define and schedule jobs \u00b6 Understanding IJob \u00b6 In NCronJob , jobs are defined by implementing the IJob interface. This interface contains a single method, RunAsync , where you define the task\u2019s execution logic. NCronJob registers IJob implementations as scoped services within your application\u2019s dependency injection container. This means that a new scope is created for each job execution, ensuring isolation and allowing for clean dependency management (particularly important when working with frameworks like Entity Framework Core). Defining a Job \u00b6 Follow these steps to create and schedule a job in NCronJob: public class MyCronJob : IJob { private readonly ILogger < MyCronJob > _logger ; public MyCronJob ( ILogger < MyCronJob > logger ) { // MyCronJob lives in the container so you can inject services here _logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { _logger . LogInformation ( \"MyCronJob is executing!\" ); // Add your job logic here (e.g., database updates, sending emails, etc.) return Task . CompletedTask ; } } Registering the Job \u00b6 using LinkDotNet.NCronJob ; // Inside your service configuration Services . AddNCronJob ( options => { options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ); // Runs every 5 minutes }); }); Chaining Cron Expressions with And \u00b6 Execute the same job on multiple schedules using the And command: Services . AddNCronJob ( options => { options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"0 8 * * *\" ) // Every day at 8:00 AM . And . WithCronExpression ( \"0 20 * * *\" ); // Every day at 8:00 PM }); }); Scheduling Jobs With Time Zones \u00b6 The library offers you the ability to schedule jobs using time zones. Services . AddNCronJob ( options => { var timeZone = TimeZoneInfo . FindSystemTimeZoneById ( \"Pacific Standard Time\" ); options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"0 15 * * *\" , timeZoneInfo : timeZone ); // Every day at 3:00 PM PST }); });","title":"Define and Schedule Jobs"},{"location":"features/define-and-schedule-jobs/#define-and-schedule-jobs","text":"","title":"Define and schedule jobs"},{"location":"features/define-and-schedule-jobs/#understanding-ijob","text":"In NCronJob , jobs are defined by implementing the IJob interface. This interface contains a single method, RunAsync , where you define the task\u2019s execution logic. NCronJob registers IJob implementations as scoped services within your application\u2019s dependency injection container. This means that a new scope is created for each job execution, ensuring isolation and allowing for clean dependency management (particularly important when working with frameworks like Entity Framework Core).","title":"Understanding IJob"},{"location":"features/define-and-schedule-jobs/#defining-a-job","text":"Follow these steps to create and schedule a job in NCronJob: public class MyCronJob : IJob { private readonly ILogger < MyCronJob > _logger ; public MyCronJob ( ILogger < MyCronJob > logger ) { // MyCronJob lives in the container so you can inject services here _logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { _logger . LogInformation ( \"MyCronJob is executing!\" ); // Add your job logic here (e.g., database updates, sending emails, etc.) return Task . CompletedTask ; } }","title":"Defining a Job"},{"location":"features/define-and-schedule-jobs/#registering-the-job","text":"using LinkDotNet.NCronJob ; // Inside your service configuration Services . AddNCronJob ( options => { options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ); // Runs every 5 minutes }); });","title":"Registering the Job"},{"location":"features/define-and-schedule-jobs/#chaining-cron-expressions-with-and","text":"Execute the same job on multiple schedules using the And command: Services . AddNCronJob ( options => { options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"0 8 * * *\" ) // Every day at 8:00 AM . And . WithCronExpression ( \"0 20 * * *\" ); // Every day at 8:00 PM }); });","title":"Chaining Cron Expressions with And"},{"location":"features/define-and-schedule-jobs/#scheduling-jobs-with-time-zones","text":"The library offers you the ability to schedule jobs using time zones. Services . AddNCronJob ( options => { var timeZone = TimeZoneInfo . FindSystemTimeZoneById ( \"Pacific Standard Time\" ); options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"0 15 * * *\" , timeZoneInfo : timeZone ); // Every day at 3:00 PM PST }); });","title":"Scheduling Jobs With Time Zones"},{"location":"features/instant-jobs/","text":"Triggering instant jobs \u00b6 NCronJob allows you to trigger jobs instantly. This is useful when you want to run a job immediately without waiting for the next scheduled time. For example you get a API request and want to offload the work to a background job immediately. Instant jobs are like \u201cregular\u201d CRON jobs and inherit from IJob . The only difference is that they are triggered manually. So also CRON jobs can be triggered instantly. public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { ParameterDto dto = ( ParameterDto ) context . Parameter ; // Do something return Task . CompletedTask ; } } As CRON jobs, they have to be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyJob >(); // No need to specify a CRON expression }); There is no need of a CRON expression for instant jobs. Also passing in parameters doesn\u2019t do anything, they will be passed in differently. Let\u2019s have a look at how to trigger an instant job. Imagine we have a Minimal API where we want to send an E-Mail: app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob < MyJob >( parameterDto ); return Results . Ok (); }); The RunInstantJob method takes the job type and the parameters as arguments. Optionally you can pass in a CancellationToken as well. The job will be executed immediately. Starting a job with a delay \u00b6 If you find the need of delaying the execution of an instant job, you can use the RunScheduledJob method with a TimeSpan as a delay. The same as RunInstantJob applies here, the job has to be registered in the AddNCronJob method. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( TimeSpan . FromMinutes ( 5 ), parameterDto ); return Results . Ok (); }); Starting a job at a specific date and time \u00b6 If you want to start a job at a specific date and time, you can use the RunScheduledJob method with a DateTimeOffset as a parameter. The same as before: The job has to be registered. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( new DateTimeOffset ( 2024 , 1 , 1 , 0 , 0 , 0 , TimeSpan . FromHours ( 2 )), parameterDto ); return Results . Ok (); });","title":"Triggering instant jobs"},{"location":"features/instant-jobs/#triggering-instant-jobs","text":"NCronJob allows you to trigger jobs instantly. This is useful when you want to run a job immediately without waiting for the next scheduled time. For example you get a API request and want to offload the work to a background job immediately. Instant jobs are like \u201cregular\u201d CRON jobs and inherit from IJob . The only difference is that they are triggered manually. So also CRON jobs can be triggered instantly. public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { ParameterDto dto = ( ParameterDto ) context . Parameter ; // Do something return Task . CompletedTask ; } } As CRON jobs, they have to be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyJob >(); // No need to specify a CRON expression }); There is no need of a CRON expression for instant jobs. Also passing in parameters doesn\u2019t do anything, they will be passed in differently. Let\u2019s have a look at how to trigger an instant job. Imagine we have a Minimal API where we want to send an E-Mail: app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob < MyJob >( parameterDto ); return Results . Ok (); }); The RunInstantJob method takes the job type and the parameters as arguments. Optionally you can pass in a CancellationToken as well. The job will be executed immediately.","title":"Triggering instant jobs"},{"location":"features/instant-jobs/#starting-a-job-with-a-delay","text":"If you find the need of delaying the execution of an instant job, you can use the RunScheduledJob method with a TimeSpan as a delay. The same as RunInstantJob applies here, the job has to be registered in the AddNCronJob method. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( TimeSpan . FromMinutes ( 5 ), parameterDto ); return Results . Ok (); });","title":"Starting a job with a delay"},{"location":"features/instant-jobs/#starting-a-job-at-a-specific-date-and-time","text":"If you want to start a job at a specific date and time, you can use the RunScheduledJob method with a DateTimeOffset as a parameter. The same as before: The job has to be registered. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( new DateTimeOffset ( 2024 , 1 , 1 , 0 , 0 , 0 , TimeSpan . FromHours ( 2 )), parameterDto ); return Results . Ok (); });","title":"Starting a job at a specific date and time"},{"location":"features/minimal-api/","text":"Minimal API \u00b6 The minimal job API offers another way of defining a cron job. It favors simplicity over feature richness. A job can be defined as such: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); This call will register all the necessary services and the job in question. The method can be called multiple times to register multiple jobs: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); builder . Services . AddNCronJob (() => { }, \"1 * * * *\" ); The minimal job API does support resolving services from the DI container. The following example demonstrates how to resolve a logger and a TimeProvider : builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); Also the JobExecutionContext and CancellationToken can be resolved from the DI container: builder . Services . AddNCronJob (( JobExecutionContext context , CancellationToken token ) => { }, \"*/5 * * * * *\" ); The token can be used to get notified when the job should be cancelled (for example if the whole application gets shut down). Of course functions can be asynchrnous in nature as well: builder . Services . AddNCronJob ( async ( HttpClient httpClient ) => { using var response = await httpClient . GetAsync ( \"https://github.com/linkdotnet/NCronJob\" ); var content = await response . Content . ReadAsStringAsync (); }, \"*/5 * * * * *\" ); There are certain restrictions that can\u2019t be enforced at compile time (due to a missing interface) which will lead to a runtime exception: The job has to return void or Task , otherwise an InvalidOperationException will be thrown. Retry-Support \u00b6 The minimal job API does support the Retry model as well. The minimal job API leverages the fact that lambdas also can have attributes: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] () => { }, \"0 * * * *\" ); To know in which attempt the job currently is, the JobExecutionContext can be used: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] ( JobExecutionContext context ) => { if ( context . Attempts == 1 ) { // First attempt } }, \"0 * * * *\" ); Concurrency-Support \u00b6 In the same way, the concurrency level can be controlled (see Concurrency ): builder . Services . AddNCronJob ([ SupportsConcurrency ( 2 )] () => { }, \"0 * * * *\" ); Now, the job can only be executed by two instances at the same time. Restrictions \u00b6 The minimal API has some restrictions over the \u201cfull approach\u201d: Some errors can only be detected at runtime (for example if the job does not return void or Task ). No support for IJobNotificationHandler No support of defining dependencies between anonymous jobs","title":"Minimal API"},{"location":"features/minimal-api/#minimal-api","text":"The minimal job API offers another way of defining a cron job. It favors simplicity over feature richness. A job can be defined as such: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); This call will register all the necessary services and the job in question. The method can be called multiple times to register multiple jobs: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); builder . Services . AddNCronJob (() => { }, \"1 * * * *\" ); The minimal job API does support resolving services from the DI container. The following example demonstrates how to resolve a logger and a TimeProvider : builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); Also the JobExecutionContext and CancellationToken can be resolved from the DI container: builder . Services . AddNCronJob (( JobExecutionContext context , CancellationToken token ) => { }, \"*/5 * * * * *\" ); The token can be used to get notified when the job should be cancelled (for example if the whole application gets shut down). Of course functions can be asynchrnous in nature as well: builder . Services . AddNCronJob ( async ( HttpClient httpClient ) => { using var response = await httpClient . GetAsync ( \"https://github.com/linkdotnet/NCronJob\" ); var content = await response . Content . ReadAsStringAsync (); }, \"*/5 * * * * *\" ); There are certain restrictions that can\u2019t be enforced at compile time (due to a missing interface) which will lead to a runtime exception: The job has to return void or Task , otherwise an InvalidOperationException will be thrown.","title":"Minimal API"},{"location":"features/minimal-api/#retry-support","text":"The minimal job API does support the Retry model as well. The minimal job API leverages the fact that lambdas also can have attributes: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] () => { }, \"0 * * * *\" ); To know in which attempt the job currently is, the JobExecutionContext can be used: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] ( JobExecutionContext context ) => { if ( context . Attempts == 1 ) { // First attempt } }, \"0 * * * *\" );","title":"Retry-Support"},{"location":"features/minimal-api/#concurrency-support","text":"In the same way, the concurrency level can be controlled (see Concurrency ): builder . Services . AddNCronJob ([ SupportsConcurrency ( 2 )] () => { }, \"0 * * * *\" ); Now, the job can only be executed by two instances at the same time.","title":"Concurrency-Support"},{"location":"features/minimal-api/#restrictions","text":"The minimal API has some restrictions over the \u201cfull approach\u201d: Some errors can only be detected at runtime (for example if the job does not return void or Task ). No support for IJobNotificationHandler No support of defining dependencies between anonymous jobs","title":"Restrictions"},{"location":"features/multiple-cron-expressions/","text":"Registering multiple CRON expressions \u00b6 The flient builder allows you to register multiple CRON expressions for a single job. This is useful when you want to run a job at different times of the day. For example: Services . AddNCronJob ( options => { // Register a job that runs at midnight and midday options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"0 0 * * *\" ) // Run at midnight . And . WithCronExpression ( \"0 12 * * *\" ); // Run at midday }); }); The And method is used to chain multiple CRON expressions together. You can chain as many expressions as you like. If a given job has the same CRON expression registered multiple times, it will be executed multiple times as well. Services . AddNCronJob ( options => { // Register a job that runs every 5 minutes options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ) // Run every 5 minutes . And . WithCronExpression ( \"*/5 * * * *\" ); // Run every 5 minutes }); }); Two instances of the ExampleJob class will be created and executed every 5 minutes.","title":"Registering multiple CRON expressions"},{"location":"features/multiple-cron-expressions/#registering-multiple-cron-expressions","text":"The flient builder allows you to register multiple CRON expressions for a single job. This is useful when you want to run a job at different times of the day. For example: Services . AddNCronJob ( options => { // Register a job that runs at midnight and midday options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"0 0 * * *\" ) // Run at midnight . And . WithCronExpression ( \"0 12 * * *\" ); // Run at midday }); }); The And method is used to chain multiple CRON expressions together. You can chain as many expressions as you like. If a given job has the same CRON expression registered multiple times, it will be executed multiple times as well. Services . AddNCronJob ( options => { // Register a job that runs every 5 minutes options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ) // Run every 5 minutes . And . WithCronExpression ( \"*/5 * * * *\" ); // Run every 5 minutes }); }); Two instances of the ExampleJob class will be created and executed every 5 minutes.","title":"Registering multiple CRON expressions"},{"location":"features/notifications/","text":"Notificatins \u00b6 NCronJob provides a way to get notified when a job is done. For this, implement a IJobNotificationHandler<TJob> and register it in your DI container. builder . Services . AddNCronJob ( options => options . AddCronJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }) . AddNotificationHandler < MyJobNotificationHandler >()); This allows to run logic after a job is done. The JobExecutionContext and the Exception (if there was one) are passed to the Handle method. public class MyJobNotificationHandler : IJobNotificationHandler < MyJob > { private readonly ILogger < MyJobNotificationHandler > logger ; public MyJobNotificationHandler ( ILogger < MyJobNotificationHandler > logger ) { this . logger = logger ; } public Task HandleAsync ( JobExecutionContext context , Exception ? exception , CancellationToken token ) { if ( exception is not null ) { logger . LogError ( exception , \"Job failed\" ); } else { logger . LogInformation ( \"Job was successful\" ); logger . LogInformation ( \"Output: {Output}\" , context . Output ); } return Task . CompletedTask ; } }","title":"Notifications"},{"location":"features/notifications/#notificatins","text":"NCronJob provides a way to get notified when a job is done. For this, implement a IJobNotificationHandler<TJob> and register it in your DI container. builder . Services . AddNCronJob ( options => options . AddCronJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }) . AddNotificationHandler < MyJobNotificationHandler >()); This allows to run logic after a job is done. The JobExecutionContext and the Exception (if there was one) are passed to the Handle method. public class MyJobNotificationHandler : IJobNotificationHandler < MyJob > { private readonly ILogger < MyJobNotificationHandler > logger ; public MyJobNotificationHandler ( ILogger < MyJobNotificationHandler > logger ) { this . logger = logger ; } public Task HandleAsync ( JobExecutionContext context , Exception ? exception , CancellationToken token ) { if ( exception is not null ) { logger . LogError ( exception , \"Job failed\" ); } else { logger . LogInformation ( \"Job was successful\" ); logger . LogInformation ( \"Output: {Output}\" , context . Output ); } return Task . CompletedTask ; } }","title":"Notificatins"},{"location":"features/parameters/","text":"Passing parameters to a job \u00b6 Often times a job needs some kind of configuration or parameter to run. Imagine you have a job that generates a report and can run daily, weekly or monthly. You could create three different jobs for each frequency, but that would be a lot of duplicated code. Instead, you can pass in parameters to the job. Services . AddNCronJob ( options => { options . AddJob < ReportJob >( j => { // Runs every day at midnight and passes in the string \"daily\" j . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"daily\" ) . And . WithCronExpression ( \"0 0 * * 0\" ). WithParameter ( \"weekly\" ) . And . WithCronExpression ( \"0 0 1 * *\" ). WithParameter ( \"monthly\" ); }); }); In the ReportJob you can now access the parameter via the JobExecutionContext : public class ReportJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var parameter = context . Parameter ; // Do something with the parameter switch ( parameter ) { case \"daily\" : // Generate daily report break ; case \"weekly\" : // Generate weekly report break ; case \"monthly\" : // Generate monthly report break ; } return Task . CompletedTask ; } } Parameters are not immutable \u00b6 Passed in parameters are not immutable by default or cloned through out the job execution. This means that if you change the parameter in the job, it will also change in the next execution. If you need to keep the parameter unchanged, you should clone it in the job. public class MyParameter { public int Counter { get ; set ; } } Services . AddNCronJob ( b => { b . AddJob < MyJob >( p => p . WithCronExpression (...)); }); public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var myParam = ( MyParameter ) context . Parameter ; myParam . Counter ++; // This will be incremented with each job run } } If MyJob runs twice already and is invoked a third time, myParam.Counter will be 2 when the function gets invoked.","title":"Passing Parameters"},{"location":"features/parameters/#passing-parameters-to-a-job","text":"Often times a job needs some kind of configuration or parameter to run. Imagine you have a job that generates a report and can run daily, weekly or monthly. You could create three different jobs for each frequency, but that would be a lot of duplicated code. Instead, you can pass in parameters to the job. Services . AddNCronJob ( options => { options . AddJob < ReportJob >( j => { // Runs every day at midnight and passes in the string \"daily\" j . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"daily\" ) . And . WithCronExpression ( \"0 0 * * 0\" ). WithParameter ( \"weekly\" ) . And . WithCronExpression ( \"0 0 1 * *\" ). WithParameter ( \"monthly\" ); }); }); In the ReportJob you can now access the parameter via the JobExecutionContext : public class ReportJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var parameter = context . Parameter ; // Do something with the parameter switch ( parameter ) { case \"daily\" : // Generate daily report break ; case \"weekly\" : // Generate weekly report break ; case \"monthly\" : // Generate monthly report break ; } return Task . CompletedTask ; } }","title":"Passing parameters to a job"},{"location":"features/parameters/#parameters-are-not-immutable","text":"Passed in parameters are not immutable by default or cloned through out the job execution. This means that if you change the parameter in the job, it will also change in the next execution. If you need to keep the parameter unchanged, you should clone it in the job. public class MyParameter { public int Counter { get ; set ; } } Services . AddNCronJob ( b => { b . AddJob < MyJob >( p => p . WithCronExpression (...)); }); public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var myParam = ( MyParameter ) context . Parameter ; myParam . Counter ++; // This will be incremented with each job run } } If MyJob runs twice already and is invoked a third time, myParam.Counter will be 2 when the function gets invoked.","title":"Parameters are not immutable"},{"location":"features/retry-support/","text":"Retry Support \u00b6 The new Retry support provides a robust mechanism for handling transient failures by retrying failed operations. This feature is implemented using the RetryPolicy attribute that can be applied to any class implementing the IJob interface. How It Works \u00b6 The RetryPolicy attribute allows you to specify the number of retry attempts and the strategy for handling retries. There are two built-in retry strategies: - ExponentialBackoff: Increases the delay between retry attempts exponentially. - FixedInterval: Keeps the delay between retry attempts consistent. Using Retry Policies \u00b6 Here are examples of how to use the built-in retry policies: Example 1: Basic Retry Policy, defaults to Exponential Backoff \u00b6 [RetryPolicy(retryCount: 4)] public class RetryJob ( ILogger < RetryJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"RetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in RetryJob.\" ); } logger . LogInformation ( $\"RetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } Example 2: Fixed Interval \u00b6 [RetryPolicy(4, PolicyType.FixedInterval)] public class FixedIntervalRetryJob ( ILogger < FixedIntervalRetryJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"FixedIntervalRetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } Advanced: Custom Retry Policies \u00b6 You can also create custom retry policies by implementing the IPolicyCreator interface. This allows you to define complex retry logic tailored to your specific needs. [RetryPolicy<MyCustomPolicyCreator>(retryCount:4, delayFactor:1)] public class CustomPolicyJob ( ILogger < CustomPolicyJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"CustomPolicyJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } public class MyCustomPolicyCreator : IPolicyCreator { public IAsyncPolicy CreatePolicy ( int maxRetryAttempts = 3 , double delayFactor = 2 ) { return Policy . Handle < Exception >() . WaitAndRetryAsync ( maxRetryAttempts , retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( delayFactor , retryAttempt ))); } }","title":"Retry support"},{"location":"features/retry-support/#retry-support","text":"The new Retry support provides a robust mechanism for handling transient failures by retrying failed operations. This feature is implemented using the RetryPolicy attribute that can be applied to any class implementing the IJob interface.","title":"Retry Support"},{"location":"features/retry-support/#how-it-works","text":"The RetryPolicy attribute allows you to specify the number of retry attempts and the strategy for handling retries. There are two built-in retry strategies: - ExponentialBackoff: Increases the delay between retry attempts exponentially. - FixedInterval: Keeps the delay between retry attempts consistent.","title":"How It Works"},{"location":"features/retry-support/#using-retry-policies","text":"Here are examples of how to use the built-in retry policies:","title":"Using Retry Policies"},{"location":"features/retry-support/#example-1-basic-retry-policy-defaults-to-exponential-backoff","text":"[RetryPolicy(retryCount: 4)] public class RetryJob ( ILogger < RetryJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"RetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in RetryJob.\" ); } logger . LogInformation ( $\"RetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } }","title":"Example 1: Basic Retry Policy, defaults to Exponential Backoff"},{"location":"features/retry-support/#example-2-fixed-interval","text":"[RetryPolicy(4, PolicyType.FixedInterval)] public class FixedIntervalRetryJob ( ILogger < FixedIntervalRetryJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"FixedIntervalRetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } }","title":"Example 2: Fixed Interval"},{"location":"features/retry-support/#advanced-custom-retry-policies","text":"You can also create custom retry policies by implementing the IPolicyCreator interface. This allows you to define complex retry logic tailored to your specific needs. [RetryPolicy<MyCustomPolicyCreator>(retryCount:4, delayFactor:1)] public class CustomPolicyJob ( ILogger < CustomPolicyJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"CustomPolicyJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } public class MyCustomPolicyCreator : IPolicyCreator { public IAsyncPolicy CreatePolicy ( int maxRetryAttempts = 3 , double delayFactor = 2 ) { return Policy . Handle < Exception >() . WaitAndRetryAsync ( maxRetryAttempts , retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( delayFactor , retryAttempt ))); } }","title":"Advanced: Custom Retry Policies"},{"location":"migration/v2/","text":"v2 Migration Guide \u00b6 This document will describe the changes made in v2 of NCronJob and how to migrate from v1 . Version 2 of NCronJob brings some breaking changes to mae a better API. CronExpression moved towards builder \u00b6 In v1 one would define as such: services . AddNCronJob (); services . AddCronJob < PrintHelloWorld >( options => { options . CronExpression = \"* * * * *\" ; options . Parameter = \"Hello World\" ; }); With v2 the CronExpression is moved towards the builder pattern and AddCronJob is merged into AddNCronJob : Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }); }); This allows to easily define multiple jobs without adding much boilerplate code. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( p => p . WithCronExpression ( \"0 * * * *\" ). WithParameter ( \"Foo\" ) . And . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"Bar\" )); });","title":"v2 Migration Guide"},{"location":"migration/v2/#v2-migration-guide","text":"This document will describe the changes made in v2 of NCronJob and how to migrate from v1 . Version 2 of NCronJob brings some breaking changes to mae a better API.","title":"v2 Migration Guide"},{"location":"migration/v2/#cronexpression-moved-towards-builder","text":"In v1 one would define as such: services . AddNCronJob (); services . AddCronJob < PrintHelloWorld >( options => { options . CronExpression = \"* * * * *\" ; options . Parameter = \"Hello World\" ; }); With v2 the CronExpression is moved towards the builder pattern and AddCronJob is merged into AddNCronJob : Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }); }); This allows to easily define multiple jobs without adding much boilerplate code. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( p => p . WithCronExpression ( \"0 * * * *\" ). WithParameter ( \"Foo\" ) . And . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"Bar\" )); });","title":"CronExpression moved towards builder"}]}