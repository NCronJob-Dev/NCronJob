{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NCronJob \u00b6 A Job Scheduler sitting on top of IHostedService in dotnet. Often times one finds themself between the simplicity of the BackgroundService / IHostedService and the complexity of a full-blown Hangfire or Quartz scheduler. This library aims to fill that gap by providing a simple and easy to use job scheduler that can be used in any dotnet application and feels \u201cnative\u201d. So no need for setting up a database, just schedule your stuff right away! The library gives you two ways of scheduling jobs: Instant jobs - just run a job right away (or with a small delay; or with a given date and time) Cron jobs - schedule a job using a cron expression This library is possible because of these wonderful people: If you want to support this project, you can: Leave a star \u2b50\ufe0f If you find issues, report them to us: https://github.com/NCronJob-Dev/NCronJob/issues If you have a feature request, let us know: https://github.com/NCronJob-Dev/NCronJob/issues","title":"NCronJob"},{"location":"#ncronjob","text":"A Job Scheduler sitting on top of IHostedService in dotnet. Often times one finds themself between the simplicity of the BackgroundService / IHostedService and the complexity of a full-blown Hangfire or Quartz scheduler. This library aims to fill that gap by providing a simple and easy to use job scheduler that can be used in any dotnet application and feels \u201cnative\u201d. So no need for setting up a database, just schedule your stuff right away! The library gives you two ways of scheduling jobs: Instant jobs - just run a job right away (or with a small delay; or with a given date and time) Cron jobs - schedule a job using a cron expression This library is possible because of these wonderful people: If you want to support this project, you can: Leave a star \u2b50\ufe0f If you find issues, report them to us: https://github.com/NCronJob-Dev/NCronJob/issues If you have a feature request, let us know: https://github.com/NCronJob-Dev/NCronJob/issues","title":"NCronJob"},{"location":"getting-started/","text":"Getting Started \u00b6 Using NCronJob is simple and easy. Just follow the steps below to get started. 1. Install the package \u00b6 Install the latest stable version of the package via NuGet: dotnet add package NCronJob Alternatively add the package reference to your .csproj file: <PackageReference Include= \"NCronJob\" Version= \"4.3.4\" /> 2. Create a job \u00b6 NCronJob offers a single way of defining jobs: by implementing the IJob interface with a single RunAsync method: public class PrintHelloWorld : IJob { private readonly ILogger < PrintHelloWorld > logger ; public PrintHelloWorld ( ILogger < PrintHelloWorld > logger ) { this . logger = logger ; } public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { logger . LogInformation ( \"Hello World\" ); logger . LogInformation ( \"Parameter: {Parameter}\" , context . Parameter ); return Task . CompletedTask ; } } 3. Register the service and the job \u00b6 The NCronJob library provides one easy entry point for all its magic, the AddNCronJob extension method on top of the IServiceCollection interface. Additionally call the UseNCronJobAsync method. builder . Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld > ( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); })); }); var app = builder . Build (); await app . UseNCronJobAsync (); app . Run (); Now your PrintHelloWorld job will run every minute and log \u201cHello World\u201d to the console. And that is all! Too complicated? \u00b6 We also over a \u201cMinimal API\u201d that allows you to define jobs similiar to the Minimal API for Controllers. builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); The job will be defined \u201cinline\u201d and is capable of resolving services from the DI container. You can read more about this in the section Minimal API .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Using NCronJob is simple and easy. Just follow the steps below to get started.","title":"Getting Started"},{"location":"getting-started/#1-install-the-package","text":"Install the latest stable version of the package via NuGet: dotnet add package NCronJob Alternatively add the package reference to your .csproj file: <PackageReference Include= \"NCronJob\" Version= \"4.3.4\" />","title":"1. Install the package"},{"location":"getting-started/#2-create-a-job","text":"NCronJob offers a single way of defining jobs: by implementing the IJob interface with a single RunAsync method: public class PrintHelloWorld : IJob { private readonly ILogger < PrintHelloWorld > logger ; public PrintHelloWorld ( ILogger < PrintHelloWorld > logger ) { this . logger = logger ; } public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { logger . LogInformation ( \"Hello World\" ); logger . LogInformation ( \"Parameter: {Parameter}\" , context . Parameter ); return Task . CompletedTask ; } }","title":"2. Create a job"},{"location":"getting-started/#3-register-the-service-and-the-job","text":"The NCronJob library provides one easy entry point for all its magic, the AddNCronJob extension method on top of the IServiceCollection interface. Additionally call the UseNCronJobAsync method. builder . Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld > ( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); })); }); var app = builder . Build (); await app . UseNCronJobAsync (); app . Run (); Now your PrintHelloWorld job will run every minute and log \u201cHello World\u201d to the console. And that is all!","title":"3. Register the service and the job"},{"location":"getting-started/#too-complicated","text":"We also over a \u201cMinimal API\u201d that allows you to define jobs similiar to the Minimal API for Controllers. builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); The job will be defined \u201cinline\u201d and is capable of resolving services from the DI container. You can read more about this in the section Minimal API .","title":"Too complicated?"},{"location":"advanced/dynamic-job-control/","text":"Dynamic Job Control \u00b6 NCronJob allows you to dynamically add or remove CRON jobs from the scheduler. This is useful when you want to add jobs at runtime or remove jobs based on some condition without restarting the scheduler. Defining job names \u00b6 The core idea is to define an unique job name for each job that might be mutated during runtime. The job name is an optional parameter: builder . Services . AddNCronJob ( builder => { builder . AddJob < SampleJob > ( p => p . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyName\" )); }); The same applies to Minimal API: builder . Services . AddNCronJob ( b => b . AddJob (() => {}, \"* * * * *\" , \"MyName\" )); Job Names \u00b6 Every recurring job (CRON job) can have a unique job name that identifies the job. Job names have to be unique across all jobs that were given a name. If a job is added without a name, it will not be possible to remove or update the job at runtime by name. Adding jobs \u00b6 To add a job at runtime, leverage the IRuntimeJobRegistry interface: app . MapPost ( \"/add-job\" , ( IRuntimeJobRegistry registry ) => { var hasSucceeded = registry . TryRegister ( n => n . AddJob < SampleJob > ( p => p . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyName\" )), out Exception ? exc ); if ( ! hasSucceeded ) { return TypedResults . Error ( exc ?. Message ); } return TypedResults . Ok (); }); The outer AddJob accepts a builder just like builder.Services.AddNCronJob does. The inner AddJob is the one that actually adds the job to the scheduler and does behave exactly the same. Removing jobs \u00b6 There are two ways to remove a job from the scheduler. By name or by type. To remove a job by name: app . MapDelete ( \"/remove-job\" , ( IRuntimeJobRegistry registry ) => { registry . RemoveJob ( \"MyName\" ); return TypedResults . Ok (); }); That will remove one job from the scheduler that has the name MyName . In contrast removing by type will remove all jobs of the given type (so zero to many jobs): app . MapDelete ( \"/remove-job\" , ( IRuntimeJobRegistry registry ) => { registry . RemoveJob < SampleJob > (); // Alternatively RemoveJob(typeof(SampleJob)) return TypedResults . Ok (); }); Updating the job schedule \u00b6 Updating the job schedule is done via the UpdateSchedule method. This method accepts a job name, a new CRON expression and optionally the time zone: app . MapPut ( \"/update-job\" , ( IRuntimeJobRegistry registry ) => { registry . UpdateSchedule ( \"MyName\" , \"* * * * *\" , TimeZoneInfo . Utc ); return TypedResults . Ok (); }); Updating a schedule will lead to the job being rescheduled with the new CRON expression. Any planned job with the \u201cold\u201d schedule will be cancelled and rescheduled with the new schedule. Updating the parameter \u00b6 Updating the parameter of a job is done via the UpdateParameter method. This method accepts a job name and a new parameter: app . MapPut ( \"/update-job\" , ( IRuntimeJobRegistry registry ) => { registry . UpdateParameter ( \"MyName\" , new MyParameter ()); return TypedResults . Ok (); }); Updating a parameter will lead to the job being rescheduled with the new parameter. Any planned job with the \u201cold\u201d parameter will be cancelled and rescheduled with the new parameter. Retrieving a job schedule by name \u00b6 To retrieve the schedule of a job by name, use the TryGetSchedule method: var found = registry . TryGetSchedule ( \"MyName\" , out string? cronExpression , out TimeZoneInfo ? timeZone ); The cron expression and time zone can be null even if the job was found. This indicates that the job has no schedule (like dependent jobs). Disabling and enabling jobs \u00b6 There are two ways to disable a job from the scheduler. By name or by type. To disable a job by name: app . MapPut ( \"/disable-job\" , ( IRuntimeJobRegistry registry ) => { registry . DisableJob ( \"MyName\" ); return TypedResults . Ok (); }); That will prevent one job named MyName from being scheduled. In contrast disabling by type will disable all jobs of the given type (so zero to many jobs): app . MapPut ( \"/disable-job\" , ( IRuntimeJobRegistry registry ) => { registry . DisableJob < SampleJob > (); // Alternatively DisableJob(typeof(SampleJob)) return TypedResults . Ok (); }); If a job is disabled, it will not be scheduled anymore. Any planned job will be cancelled and the job will be removed from the scheduler. Of course, it\u2019s also possible to enable back previously disabled jobs. To enable a job by name: app . MapPut ( \"/enable-job\" , ( IRuntimeJobRegistry registry ) => { registry . EnableJob ( \"MyName\" ); return TypedResults . Ok (); }); And similarly, to enable all jobs of the given type (so zero to many jobs): app . MapPut ( \"/enable-job\" , ( IRuntimeJobRegistry registry ) => { registry . EnableJob < SampleJob > (); // Alternatively EnableJob(typeof(SampleJob)) return TypedResults . Ok (); });","title":"Dynamic Job Control"},{"location":"advanced/dynamic-job-control/#dynamic-job-control","text":"NCronJob allows you to dynamically add or remove CRON jobs from the scheduler. This is useful when you want to add jobs at runtime or remove jobs based on some condition without restarting the scheduler.","title":"Dynamic Job Control"},{"location":"advanced/dynamic-job-control/#defining-job-names","text":"The core idea is to define an unique job name for each job that might be mutated during runtime. The job name is an optional parameter: builder . Services . AddNCronJob ( builder => { builder . AddJob < SampleJob > ( p => p . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyName\" )); }); The same applies to Minimal API: builder . Services . AddNCronJob ( b => b . AddJob (() => {}, \"* * * * *\" , \"MyName\" ));","title":"Defining job names"},{"location":"advanced/dynamic-job-control/#job-names","text":"Every recurring job (CRON job) can have a unique job name that identifies the job. Job names have to be unique across all jobs that were given a name. If a job is added without a name, it will not be possible to remove or update the job at runtime by name.","title":"Job Names"},{"location":"advanced/dynamic-job-control/#adding-jobs","text":"To add a job at runtime, leverage the IRuntimeJobRegistry interface: app . MapPost ( \"/add-job\" , ( IRuntimeJobRegistry registry ) => { var hasSucceeded = registry . TryRegister ( n => n . AddJob < SampleJob > ( p => p . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyName\" )), out Exception ? exc ); if ( ! hasSucceeded ) { return TypedResults . Error ( exc ?. Message ); } return TypedResults . Ok (); }); The outer AddJob accepts a builder just like builder.Services.AddNCronJob does. The inner AddJob is the one that actually adds the job to the scheduler and does behave exactly the same.","title":"Adding jobs"},{"location":"advanced/dynamic-job-control/#removing-jobs","text":"There are two ways to remove a job from the scheduler. By name or by type. To remove a job by name: app . MapDelete ( \"/remove-job\" , ( IRuntimeJobRegistry registry ) => { registry . RemoveJob ( \"MyName\" ); return TypedResults . Ok (); }); That will remove one job from the scheduler that has the name MyName . In contrast removing by type will remove all jobs of the given type (so zero to many jobs): app . MapDelete ( \"/remove-job\" , ( IRuntimeJobRegistry registry ) => { registry . RemoveJob < SampleJob > (); // Alternatively RemoveJob(typeof(SampleJob)) return TypedResults . Ok (); });","title":"Removing jobs"},{"location":"advanced/dynamic-job-control/#updating-the-job-schedule","text":"Updating the job schedule is done via the UpdateSchedule method. This method accepts a job name, a new CRON expression and optionally the time zone: app . MapPut ( \"/update-job\" , ( IRuntimeJobRegistry registry ) => { registry . UpdateSchedule ( \"MyName\" , \"* * * * *\" , TimeZoneInfo . Utc ); return TypedResults . Ok (); }); Updating a schedule will lead to the job being rescheduled with the new CRON expression. Any planned job with the \u201cold\u201d schedule will be cancelled and rescheduled with the new schedule.","title":"Updating the job schedule"},{"location":"advanced/dynamic-job-control/#updating-the-parameter","text":"Updating the parameter of a job is done via the UpdateParameter method. This method accepts a job name and a new parameter: app . MapPut ( \"/update-job\" , ( IRuntimeJobRegistry registry ) => { registry . UpdateParameter ( \"MyName\" , new MyParameter ()); return TypedResults . Ok (); }); Updating a parameter will lead to the job being rescheduled with the new parameter. Any planned job with the \u201cold\u201d parameter will be cancelled and rescheduled with the new parameter.","title":"Updating the parameter"},{"location":"advanced/dynamic-job-control/#retrieving-a-job-schedule-by-name","text":"To retrieve the schedule of a job by name, use the TryGetSchedule method: var found = registry . TryGetSchedule ( \"MyName\" , out string? cronExpression , out TimeZoneInfo ? timeZone ); The cron expression and time zone can be null even if the job was found. This indicates that the job has no schedule (like dependent jobs).","title":"Retrieving a job schedule by name"},{"location":"advanced/dynamic-job-control/#disabling-and-enabling-jobs","text":"There are two ways to disable a job from the scheduler. By name or by type. To disable a job by name: app . MapPut ( \"/disable-job\" , ( IRuntimeJobRegistry registry ) => { registry . DisableJob ( \"MyName\" ); return TypedResults . Ok (); }); That will prevent one job named MyName from being scheduled. In contrast disabling by type will disable all jobs of the given type (so zero to many jobs): app . MapPut ( \"/disable-job\" , ( IRuntimeJobRegistry registry ) => { registry . DisableJob < SampleJob > (); // Alternatively DisableJob(typeof(SampleJob)) return TypedResults . Ok (); }); If a job is disabled, it will not be scheduled anymore. Any planned job will be cancelled and the job will be removed from the scheduler. Of course, it\u2019s also possible to enable back previously disabled jobs. To enable a job by name: app . MapPut ( \"/enable-job\" , ( IRuntimeJobRegistry registry ) => { registry . EnableJob ( \"MyName\" ); return TypedResults . Ok (); }); And similarly, to enable all jobs of the given type (so zero to many jobs): app . MapPut ( \"/enable-job\" , ( IRuntimeJobRegistry registry ) => { registry . EnableJob < SampleJob > (); // Alternatively EnableJob(typeof(SampleJob)) return TypedResults . Ok (); });","title":"Disabling and enabling jobs"},{"location":"advanced/global-concurrency/","text":"Global Concurrency \u00b6 NCronJob relies on a priority queue with a maximum amount of entries. That is, the queue will only hold and execute a maximum amount of jobs at any given time. This is to prevent the system from being overloaded with jobs. The Maximum \u00b6 The global maximum of concurrent jobs is calculated as: var maxDegreeOfParallelism = Environment . ProcessorCount * 4 ; If you have a CPU with 12 Cores (like a M2 Processor), the maximum amount of concurrent jobs will be 48. A CRON job is rescheduled after it has been executed. This means that the queue will always be filled with jobs that are ready to be executed. If that queue is full, no more jobs will be added to the queue until a job has been executed. A simple example: You have only one processor (therefore maximum 4 jobs executed at the same time) and a cron job that runs every minute. The job takes six minutes to complete. So after four minutes the queue is full, and no more jobs will be added to the queue. After the fifth minute, the queue is still full, and no more jobs will be added to the queue. After the sixth minute, the first job is removed from the queue, and the next job is added to the queue. Therefore it can happen that jobs are skipped and not executed. The same applies to the SupportsConcurrencyAttribute discussed in: Concurrency Control","title":"Global Concurrency"},{"location":"advanced/global-concurrency/#global-concurrency","text":"NCronJob relies on a priority queue with a maximum amount of entries. That is, the queue will only hold and execute a maximum amount of jobs at any given time. This is to prevent the system from being overloaded with jobs.","title":"Global Concurrency"},{"location":"advanced/global-concurrency/#the-maximum","text":"The global maximum of concurrent jobs is calculated as: var maxDegreeOfParallelism = Environment . ProcessorCount * 4 ; If you have a CPU with 12 Cores (like a M2 Processor), the maximum amount of concurrent jobs will be 48. A CRON job is rescheduled after it has been executed. This means that the queue will always be filled with jobs that are ready to be executed. If that queue is full, no more jobs will be added to the queue until a job has been executed. A simple example: You have only one processor (therefore maximum 4 jobs executed at the same time) and a cron job that runs every minute. The job takes six minutes to complete. So after four minutes the queue is full, and no more jobs will be added to the queue. After the fifth minute, the queue is still full, and no more jobs will be added to the queue. After the sixth minute, the first job is removed from the queue, and the next job is added to the queue. Therefore it can happen that jobs are skipped and not executed. The same applies to the SupportsConcurrencyAttribute discussed in: Concurrency Control","title":"The Maximum"},{"location":"advanced/log-level/","text":"Controlling the log-level \u00b6 The NCronJob scheduler can be configured to log at a specific log level. { \"Logging\" : { \"LogLevel\" : { \"Default\" : \"Information\" , \"Microsoft.AspNetCore\" : \"Warning\" , \"NCronJob\" : \"Debug\"","title":"Controlling the log level"},{"location":"advanced/log-level/#controlling-the-log-level","text":"The NCronJob scheduler can be configured to log at a specific log level. { \"Logging\" : { \"LogLevel\" : { \"Default\" : \"Information\" , \"Microsoft.AspNetCore\" : \"Warning\" , \"NCronJob\" : \"Debug\"","title":"Controlling the log-level"},{"location":"advanced/observing-job-progress/","text":"Observing job progress \u00b6 Every time one schedules a job (or triggers it as an instant job), a virtual orchestration is spawned. An orchestration can be as simple as a unique job, or as complex as a root job and the whole hierarchy of its direct and indirect dependent jobs (see \u201cModel Dependencies\u201d ). An orchestration is uniquely identifed by an identifier. All jobs belonging to an orchestration share this same CorrelationId (See \u201cTracing requests of dependencies via CorrelationId \u201c ). From a timeline perspective, an orchestration starts before the root job that initiated it and completes when all of its leaf jobs have reached a final state. Subscribing to the executions of jobs \u00b6 Forewords \u00b6 Warning This is an experimental feature subject to breaking changes independently of the standard semver lifecycle release of NCronJob . While reporting feedback or bugs about it, please do not forget to mention in the issue which version of NCronJob you\u2019re using. Would you decide to give it an early try, in order to suppress the warnings that comes with the .NET Experimental attribute , update your .csproj with a <NoWarn> project setting: <PropertyGroup> ... <NoWarn> $(NoWarn);NCRONJOB_OBSERVER </NoWarn> </PropertyGroup> Alternatively, it can also be silenced through an .editorconfig setting. [*.cs] ... # NCRONJOB_OBSERVER: Type is for evaluation purposes only and is subject to change or removal in future updates. dotnet_diagnostic.NCRONJOB_OBSERVER.severity = none Registering a notifier callback \u00b6 NCronJob exposes the capability to notify whenever jobs change states. One can suscribe to this by leveraging the IJobExecutionProgressReporter service. This is done through the following exposed method IDisposable Register ( Action < ExecutionProgress > callback ); Info The registration returns the subscription as a IDisposable object. In order to stop the callback from receiving notifications anymore, invoke the Dispose() method of it. Subscribers to the reporting service will receive an immutable instance of the ExecutionProgress . This type will expose every meaningful change to any job or orchestration handled by NCronJob. Sample usage \u00b6 Considering the following orchestration A \u2500\u252c\u2500 (successful) \u2500\u2500> B \u2514\u2500 (successful) \u2500\u2500> C \u2500\u2500\u2500 (successful) \u2500\u2500> D Below a very simple approach to schedule it every minute and register a subscriber. using NCronJob ; public class A : IJob { public A ( ILogger < A > logger ) => Logger = logger ; public ILogger < A > Logger { get ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { Logger . LogInformation ( \"[A]: Starting processing...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 1 ), token ); Logger . LogInformation ( \"[A]: Processing is done.\" ); } } public class B : IJob { public B ( ILogger < B > logger ) => Logger = logger ; public ILogger < B > Logger { get ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { Logger . LogInformation ( \"[B]: Starting processing...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 6 ), token ); Logger . LogInformation ( \"[B]: Processing is done.\" ); } } public class C : IJob { public C ( ILogger < C > logger ) => Logger = logger ; public ILogger < C > Logger { get ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { Logger . LogInformation ( \"[C]: Starting processing...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 1 ), token ); Logger . LogInformation ( \"[C]: Processing is done.\" ); } } public class D : IJob { public D ( ILogger < D > logger ) => Logger = logger ; public ILogger < D > Logger { get ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { Logger . LogInformation ( \"[D]: Starting processing...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 1 ), token ); Logger . LogInformation ( \"[D]: Processing is done.\" ); } } public class Program { private static async Task Main ( string [] args ) { var builder = Host . CreateApplicationBuilder ( args ); builder . Services . AddNCronJob ( n => { n . AddJob < D > (); n . AddJob < C > () . ExecuteWhen ( success : s => s . RunJob < D > ()); n . AddJob < B > (); n . AddJob < A > ( o => o . WithCronExpression ( \"* * * * *\" )) . ExecuteWhen ( success : s => s . RunJob < B > ()) . ExecuteWhen ( success : s => s . RunJob < C > ()); }); var app = builder . Build (); await app . UseNCronJobAsync (); var logger = app . Services . GetRequiredService < ILogger < Program >> (); // Retrieve the observer service from the DI container... var reporter = app . Services . GetRequiredService < IJobExecutionProgressReporter > (); // ...enlist a new subscriber to it... IDisposable subscription = reporter . Register ( Subscriber ); await app . RunAsync (); // ...and when you're done with it, unhook the subscription. subscription . Dispose (); void Subscriber ( ExecutionProgress progress ) { if ( progress . RunId is null ) { logger . LogWarning ( \"Orchestration {CorrelationId} - {Status}\" , progress . CorrelationId , progress . State ); return ; } logger . LogWarning ( \"Job {JobRunId} - {Status}\" , progress . RunId , progress . State ); } } } Given the orchestration defined above, with jobs of varying durations, the generated output log may look like this: 10:46:47 warn: Program[0] Orchestration d36e2b62-6997-44c5-a9f9-de442b8a1807 - OrchestrationStarted 10:46:50 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - NotStarted 10:46:50 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Scheduled 10:47:00 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Initializing 10:47:00 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Running 10:47:00 info: A[0] [A]: Starting processing... 10:47:01 info: A[0] [A]: Processing is done. 10:47:01 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Completing 10:47:01 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - WaitingForDependency 10:47:01 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - NotStarted 10:47:01 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - NotStarted 10:47:01 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Completed 10:47:01 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - Initializing 10:47:01 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - Running 10:47:01 info: B[0] [B]: Starting processing... 10:47:01 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - Initializing 10:47:01 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - Running 10:47:01 info: C[0] [C]: Starting processing... 10:47:02 info: C[0] [C]: Processing is done. 10:47:02 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - Completing 10:47:02 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - WaitingForDependency 10:47:02 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - NotStarted 10:47:02 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - Completed 10:47:03 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - Initializing 10:47:03 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - Running 10:47:03 info: D[0] [D]: Starting processing... 10:47:04 info: D[0] [D]: Processing is done. 10:47:04 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - Completing 10:47:04 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - Completed 10:47:07 info: B[0] [B]: Processing is done. 10:47:07 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - Completing 10:47:07 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - Completed 10:47:07 warn: Program[0] Orchestration d36e2b62-6997-44c5-a9f9-de442b8a1807 - OrchestrationCompleted Known limitations \u00b6 As global NCronJob observability is still under development, it\u2019s not feature complete yet. Below are know missing parts of it. Would you find other releated areas of interest that may be worth investigating, please submit a request in the issue tracker. ~~ Report removed jobs as Cancelled ~~ ~~ Report skipped child jobs as Skipped ~~","title":"Observing progress of jobs"},{"location":"advanced/observing-job-progress/#observing-job-progress","text":"Every time one schedules a job (or triggers it as an instant job), a virtual orchestration is spawned. An orchestration can be as simple as a unique job, or as complex as a root job and the whole hierarchy of its direct and indirect dependent jobs (see \u201cModel Dependencies\u201d ). An orchestration is uniquely identifed by an identifier. All jobs belonging to an orchestration share this same CorrelationId (See \u201cTracing requests of dependencies via CorrelationId \u201c ). From a timeline perspective, an orchestration starts before the root job that initiated it and completes when all of its leaf jobs have reached a final state.","title":"Observing job progress"},{"location":"advanced/observing-job-progress/#subscribing-to-the-executions-of-jobs","text":"","title":"Subscribing to the executions of jobs"},{"location":"advanced/observing-job-progress/#forewords","text":"Warning This is an experimental feature subject to breaking changes independently of the standard semver lifecycle release of NCronJob . While reporting feedback or bugs about it, please do not forget to mention in the issue which version of NCronJob you\u2019re using. Would you decide to give it an early try, in order to suppress the warnings that comes with the .NET Experimental attribute , update your .csproj with a <NoWarn> project setting: <PropertyGroup> ... <NoWarn> $(NoWarn);NCRONJOB_OBSERVER </NoWarn> </PropertyGroup> Alternatively, it can also be silenced through an .editorconfig setting. [*.cs] ... # NCRONJOB_OBSERVER: Type is for evaluation purposes only and is subject to change or removal in future updates. dotnet_diagnostic.NCRONJOB_OBSERVER.severity = none","title":"Forewords"},{"location":"advanced/observing-job-progress/#registering-a-notifier-callback","text":"NCronJob exposes the capability to notify whenever jobs change states. One can suscribe to this by leveraging the IJobExecutionProgressReporter service. This is done through the following exposed method IDisposable Register ( Action < ExecutionProgress > callback ); Info The registration returns the subscription as a IDisposable object. In order to stop the callback from receiving notifications anymore, invoke the Dispose() method of it. Subscribers to the reporting service will receive an immutable instance of the ExecutionProgress . This type will expose every meaningful change to any job or orchestration handled by NCronJob.","title":"Registering a notifier callback"},{"location":"advanced/observing-job-progress/#sample-usage","text":"Considering the following orchestration A \u2500\u252c\u2500 (successful) \u2500\u2500> B \u2514\u2500 (successful) \u2500\u2500> C \u2500\u2500\u2500 (successful) \u2500\u2500> D Below a very simple approach to schedule it every minute and register a subscriber. using NCronJob ; public class A : IJob { public A ( ILogger < A > logger ) => Logger = logger ; public ILogger < A > Logger { get ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { Logger . LogInformation ( \"[A]: Starting processing...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 1 ), token ); Logger . LogInformation ( \"[A]: Processing is done.\" ); } } public class B : IJob { public B ( ILogger < B > logger ) => Logger = logger ; public ILogger < B > Logger { get ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { Logger . LogInformation ( \"[B]: Starting processing...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 6 ), token ); Logger . LogInformation ( \"[B]: Processing is done.\" ); } } public class C : IJob { public C ( ILogger < C > logger ) => Logger = logger ; public ILogger < C > Logger { get ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { Logger . LogInformation ( \"[C]: Starting processing...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 1 ), token ); Logger . LogInformation ( \"[C]: Processing is done.\" ); } } public class D : IJob { public D ( ILogger < D > logger ) => Logger = logger ; public ILogger < D > Logger { get ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { Logger . LogInformation ( \"[D]: Starting processing...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 1 ), token ); Logger . LogInformation ( \"[D]: Processing is done.\" ); } } public class Program { private static async Task Main ( string [] args ) { var builder = Host . CreateApplicationBuilder ( args ); builder . Services . AddNCronJob ( n => { n . AddJob < D > (); n . AddJob < C > () . ExecuteWhen ( success : s => s . RunJob < D > ()); n . AddJob < B > (); n . AddJob < A > ( o => o . WithCronExpression ( \"* * * * *\" )) . ExecuteWhen ( success : s => s . RunJob < B > ()) . ExecuteWhen ( success : s => s . RunJob < C > ()); }); var app = builder . Build (); await app . UseNCronJobAsync (); var logger = app . Services . GetRequiredService < ILogger < Program >> (); // Retrieve the observer service from the DI container... var reporter = app . Services . GetRequiredService < IJobExecutionProgressReporter > (); // ...enlist a new subscriber to it... IDisposable subscription = reporter . Register ( Subscriber ); await app . RunAsync (); // ...and when you're done with it, unhook the subscription. subscription . Dispose (); void Subscriber ( ExecutionProgress progress ) { if ( progress . RunId is null ) { logger . LogWarning ( \"Orchestration {CorrelationId} - {Status}\" , progress . CorrelationId , progress . State ); return ; } logger . LogWarning ( \"Job {JobRunId} - {Status}\" , progress . RunId , progress . State ); } } } Given the orchestration defined above, with jobs of varying durations, the generated output log may look like this: 10:46:47 warn: Program[0] Orchestration d36e2b62-6997-44c5-a9f9-de442b8a1807 - OrchestrationStarted 10:46:50 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - NotStarted 10:46:50 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Scheduled 10:47:00 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Initializing 10:47:00 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Running 10:47:00 info: A[0] [A]: Starting processing... 10:47:01 info: A[0] [A]: Processing is done. 10:47:01 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Completing 10:47:01 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - WaitingForDependency 10:47:01 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - NotStarted 10:47:01 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - NotStarted 10:47:01 warn: Program[0] Job d751f2eb-9f8d-46e3-b863-6dadc6498468 - Completed 10:47:01 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - Initializing 10:47:01 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - Running 10:47:01 info: B[0] [B]: Starting processing... 10:47:01 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - Initializing 10:47:01 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - Running 10:47:01 info: C[0] [C]: Starting processing... 10:47:02 info: C[0] [C]: Processing is done. 10:47:02 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - Completing 10:47:02 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - WaitingForDependency 10:47:02 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - NotStarted 10:47:02 warn: Program[0] Job f28acd5e-cd3e-445e-979c-59a160035ef2 - Completed 10:47:03 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - Initializing 10:47:03 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - Running 10:47:03 info: D[0] [D]: Starting processing... 10:47:04 info: D[0] [D]: Processing is done. 10:47:04 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - Completing 10:47:04 warn: Program[0] Job f4a8ef3b-4848-4363-a3b7-f847562598b3 - Completed 10:47:07 info: B[0] [B]: Processing is done. 10:47:07 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - Completing 10:47:07 warn: Program[0] Job 27509f28-d84b-4d50-8f9d-e5500bbc17fa - Completed 10:47:07 warn: Program[0] Orchestration d36e2b62-6997-44c5-a9f9-de442b8a1807 - OrchestrationCompleted","title":"Sample usage"},{"location":"advanced/observing-job-progress/#known-limitations","text":"As global NCronJob observability is still under development, it\u2019s not feature complete yet. Below are know missing parts of it. Would you find other releated areas of interest that may be worth investigating, please submit a request in the issue tracker. ~~ Report removed jobs as Cancelled ~~ ~~ Report skipped child jobs as Skipped ~~","title":"Known limitations"},{"location":"features/concurrency-control/","text":"Concurrency Control \u00b6 Concurrency support allows multiple instances of the same job type to run simultaneously, controlled by the SupportsConcurrency attribute. This feature is crucial for efficiently managing jobs that are capable of running in parallel without interference. By default jobs are not executed concurrently if the SupportsConcurrency attribute is not set. How It Works \u00b6 The SupportsConcurrency attribute specifies the maximum degree of parallelism for job instances. This means you can define how many instances of a particular job can run concurrently, optimizing performance and resource utilization based on the nature of the job and the system capabilities. Using the SupportsConcurrency Attribute \u00b6 Here is an example of how to apply this attribute to a job: Example: Concurrency in Jobs \u00b6 [SupportsConcurrency(10)] public class ConcurrentJob : IJob { private readonly ILogger < ConcurrentJob > logger ; public ConcurrentJob ( ILogger < ConcurrentJob > logger ) { this . logger = logger ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} is running.\" ); // Simulate some work by delaying await Task . Delay ( 5000 , token ); logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} has completed.\" ); } } Important Considerations \u00b6 Ensuring Job Idempotency \u00b6 When using concurrency, it\u2019s essential to ensure that each job instance is idempotent. This means that even if the job is executed multiple times concurrently or sequentially, the outcome and side effects should remain consistent, without unintended duplication or conflict. Resource Allocation Caution \u00b6 Jobs that are marked to support concurrency should be designed carefully to avoid contention over shared resources. This includes, but is not limited to, database connections, file handles, or any external systems. In scenarios where shared resources are unavoidable, proper synchronization mechanisms or concurrency control techniques, such as semaphores, mutexes, or transactional control, should be implemented to prevent race conditions and ensure data integrity.","title":"Concurrency control"},{"location":"features/concurrency-control/#concurrency-control","text":"Concurrency support allows multiple instances of the same job type to run simultaneously, controlled by the SupportsConcurrency attribute. This feature is crucial for efficiently managing jobs that are capable of running in parallel without interference. By default jobs are not executed concurrently if the SupportsConcurrency attribute is not set.","title":"Concurrency Control"},{"location":"features/concurrency-control/#how-it-works","text":"The SupportsConcurrency attribute specifies the maximum degree of parallelism for job instances. This means you can define how many instances of a particular job can run concurrently, optimizing performance and resource utilization based on the nature of the job and the system capabilities.","title":"How It Works"},{"location":"features/concurrency-control/#using-the-supportsconcurrency-attribute","text":"Here is an example of how to apply this attribute to a job:","title":"Using the SupportsConcurrency Attribute"},{"location":"features/concurrency-control/#example-concurrency-in-jobs","text":"[SupportsConcurrency(10)] public class ConcurrentJob : IJob { private readonly ILogger < ConcurrentJob > logger ; public ConcurrentJob ( ILogger < ConcurrentJob > logger ) { this . logger = logger ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} is running.\" ); // Simulate some work by delaying await Task . Delay ( 5000 , token ); logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} has completed.\" ); } }","title":"Example: Concurrency in Jobs"},{"location":"features/concurrency-control/#important-considerations","text":"","title":"Important Considerations"},{"location":"features/concurrency-control/#ensuring-job-idempotency","text":"When using concurrency, it\u2019s essential to ensure that each job instance is idempotent. This means that even if the job is executed multiple times concurrently or sequentially, the outcome and side effects should remain consistent, without unintended duplication or conflict.","title":"Ensuring Job Idempotency"},{"location":"features/concurrency-control/#resource-allocation-caution","text":"Jobs that are marked to support concurrency should be designed carefully to avoid contention over shared resources. This includes, but is not limited to, database connections, file handles, or any external systems. In scenarios where shared resources are unavoidable, proper synchronization mechanisms or concurrency control techniques, such as semaphores, mutexes, or transactional control, should be implemented to prevent race conditions and ensure data integrity.","title":"Resource Allocation Caution"},{"location":"features/define-and-schedule-jobs/","text":"Define and schedule jobs \u00b6 Understanding IJob \u00b6 In NCronJob , jobs are defined by implementing the IJob interface. This interface contains a single method, RunAsync , where you define the task\u2019s execution logic. NCronJob registers IJob implementations as scoped services within your application\u2019s dependency injection container. This means that a new scope is created for each job execution, ensuring isolation and allowing for clean dependency management (particularly important when working with frameworks like Entity Framework Core). Defining a Job \u00b6 Follow these steps to create and schedule a job in NCronJob: public class MyCronJob : IJob { private readonly ILogger < MyCronJob > _logger ; public MyCronJob ( ILogger < MyCronJob > logger ) { // MyCronJob lives in the container so you can inject services here _logger = logger ; } public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { _logger . LogInformation ( \"MyCronJob is executing!\" ); // Add your job logic here (e.g., database updates, sending emails, etc.) return Task . CompletedTask ; } } Registering the Job \u00b6 using NCronJob ; // Inside your service configuration Services . AddNCronJob ( options => { options . AddJob < MyCronJob > ( j => { j . WithCronExpression ( \"*/5 * * * *\" ); // Runs every 5 minutes }); }); Chaining Cron Expressions with And \u00b6 Execute the same job on multiple schedules using the And command: Services . AddNCronJob ( options => { options . AddJob < MyCronJob > ( j => { j . WithCronExpression ( \"0 8 * * *\" ) // Every day at 8:00 AM . And . WithCronExpression ( \"0 20 * * *\" ); // Every day at 8:00 PM }); }); Info Defining multiple identifical schedules for the same job will not lead to multiple instances of the job running concurrently. NCronJob will ensure that only one instance of the job is running at any given time. One can define different custom names for each schedule to differentiate between them. See \u201cDefining job names\u201d . The following example illustrates how to define multiple schedules that are identical and will only lead to one instance of the job running at any given time: Services . AddNCronJob ( options => { options . AddJob < MyCronJob > ( j => { j . WithCronExpression ( \"0 20 * * *\" ) . And . WithCronExpression ( \"0 20 * * *\" ); }); }); Scheduling Jobs With Time Zones \u00b6 The library offers you the ability to schedule jobs using time zones. Services . AddNCronJob ( options => { var timeZone = TimeZoneInfo . FindSystemTimeZoneById ( \"Pacific Standard Time\" ); options . AddJob < MyCronJob > ( j => { j . WithCronExpression ( \"0 15 * * *\" , timeZoneInfo : timeZone ); // Every day at 3:00 PM PST }); });","title":"Define and Schedule Jobs"},{"location":"features/define-and-schedule-jobs/#define-and-schedule-jobs","text":"","title":"Define and schedule jobs"},{"location":"features/define-and-schedule-jobs/#understanding-ijob","text":"In NCronJob , jobs are defined by implementing the IJob interface. This interface contains a single method, RunAsync , where you define the task\u2019s execution logic. NCronJob registers IJob implementations as scoped services within your application\u2019s dependency injection container. This means that a new scope is created for each job execution, ensuring isolation and allowing for clean dependency management (particularly important when working with frameworks like Entity Framework Core).","title":"Understanding IJob"},{"location":"features/define-and-schedule-jobs/#defining-a-job","text":"Follow these steps to create and schedule a job in NCronJob: public class MyCronJob : IJob { private readonly ILogger < MyCronJob > _logger ; public MyCronJob ( ILogger < MyCronJob > logger ) { // MyCronJob lives in the container so you can inject services here _logger = logger ; } public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { _logger . LogInformation ( \"MyCronJob is executing!\" ); // Add your job logic here (e.g., database updates, sending emails, etc.) return Task . CompletedTask ; } }","title":"Defining a Job"},{"location":"features/define-and-schedule-jobs/#registering-the-job","text":"using NCronJob ; // Inside your service configuration Services . AddNCronJob ( options => { options . AddJob < MyCronJob > ( j => { j . WithCronExpression ( \"*/5 * * * *\" ); // Runs every 5 minutes }); });","title":"Registering the Job"},{"location":"features/define-and-schedule-jobs/#chaining-cron-expressions-with-and","text":"Execute the same job on multiple schedules using the And command: Services . AddNCronJob ( options => { options . AddJob < MyCronJob > ( j => { j . WithCronExpression ( \"0 8 * * *\" ) // Every day at 8:00 AM . And . WithCronExpression ( \"0 20 * * *\" ); // Every day at 8:00 PM }); }); Info Defining multiple identifical schedules for the same job will not lead to multiple instances of the job running concurrently. NCronJob will ensure that only one instance of the job is running at any given time. One can define different custom names for each schedule to differentiate between them. See \u201cDefining job names\u201d . The following example illustrates how to define multiple schedules that are identical and will only lead to one instance of the job running at any given time: Services . AddNCronJob ( options => { options . AddJob < MyCronJob > ( j => { j . WithCronExpression ( \"0 20 * * *\" ) . And . WithCronExpression ( \"0 20 * * *\" ); }); });","title":"Chaining Cron Expressions with And"},{"location":"features/define-and-schedule-jobs/#scheduling-jobs-with-time-zones","text":"The library offers you the ability to schedule jobs using time zones. Services . AddNCronJob ( options => { var timeZone = TimeZoneInfo . FindSystemTimeZoneById ( \"Pacific Standard Time\" ); options . AddJob < MyCronJob > ( j => { j . WithCronExpression ( \"0 15 * * *\" , timeZoneInfo : timeZone ); // Every day at 3:00 PM PST }); });","title":"Scheduling Jobs With Time Zones"},{"location":"features/exception-handler/","text":"Exception Handler \u00b6 NCronJob , much like ASP.NET , offers a central way to handle exceptions. This is useful when you want to log exceptions or send an E-Mail when a job fails. The exception handler has to inherit from the IExceptionHandler interface. public class MyExceptionHandler : IExceptionHandler { public Task < bool > TryHandleAsync ( JobExecutionContext context , Exception exc , CancellationToken token ) { // Handle the exception return Task . FromResult ( true ); } } If the TryHandleAsync method returns true , the exception is considered as handled and no other exception handler will be called. If it returns false , the next exception handler will be called, if available. Therefore the order of registration is important. The first registered exception handler will be called first. Order of execution with NotificationHandlers \u00b6 All exception handlers are executed before the IJobNotificationHandler for that specific job is called. Independent if the exception handler returns true or false , the IJobNotificationHandler will get the exception passed in. Exceptions when a job is created \u00b6 If an exception occurs when a job is created and therefore the job can not be executed/scheduled, the exception handler will be called with the exception that occurred (and logs the exception to the active logger). NCronJob will not crash in this case. Furthermore, if a dependent job is configured that should run when the parent job fails, the dependent job will be executed in this case.","title":"Exception handler"},{"location":"features/exception-handler/#exception-handler","text":"NCronJob , much like ASP.NET , offers a central way to handle exceptions. This is useful when you want to log exceptions or send an E-Mail when a job fails. The exception handler has to inherit from the IExceptionHandler interface. public class MyExceptionHandler : IExceptionHandler { public Task < bool > TryHandleAsync ( JobExecutionContext context , Exception exc , CancellationToken token ) { // Handle the exception return Task . FromResult ( true ); } } If the TryHandleAsync method returns true , the exception is considered as handled and no other exception handler will be called. If it returns false , the next exception handler will be called, if available. Therefore the order of registration is important. The first registered exception handler will be called first.","title":"Exception Handler"},{"location":"features/exception-handler/#order-of-execution-with-notificationhandlers","text":"All exception handlers are executed before the IJobNotificationHandler for that specific job is called. Independent if the exception handler returns true or false , the IJobNotificationHandler will get the exception passed in.","title":"Order of execution with NotificationHandlers"},{"location":"features/exception-handler/#exceptions-when-a-job-is-created","text":"If an exception occurs when a job is created and therefore the job can not be executed/scheduled, the exception handler will be called with the exception that occurred (and logs the exception to the active logger). NCronJob will not crash in this case. Furthermore, if a dependent job is configured that should run when the parent job fails, the dependent job will be executed in this case.","title":"Exceptions when a job is created"},{"location":"features/instant-jobs/","text":"Triggering instant jobs \u00b6 NCronJob allows you to trigger jobs instantly. This is useful when you want to run a job immediately without waiting for the next scheduled time. For example you get a API request and want to offload the work to a background job immediately. Instant jobs are like \u201cregular\u201d CRON jobs and inherit from IJob . The only difference is that they are triggered manually. So also CRON jobs can be triggered instantly. public class MyJob : IJob { public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { ParameterDto dto = ( ParameterDto ) context . Parameter ; // Do something return Task . CompletedTask ; } } As CRON jobs, they have to be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyJob > (); // No need to specify a CRON expression }); There is no need of a CRON expression for instant jobs. Also passing in parameters doesn\u2019t do anything, they will be passed in differently. Let\u2019s have a look at how to trigger an instant job. Imagine we have a Minimal API where we want to send an E-Mail: app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob < MyJob > ( parameterDto ); return Results . Ok (); }); The RunInstantJob method takes the job type and the parameters as arguments. Optionally you can pass in a CancellationToken as well. The job will be executed immediately. Starting a job with a delay \u00b6 If you find the need to delay the execution of an instant job, you can use the RunScheduledJob method with a TimeSpan as a delay. The same as RunInstantJob applies here, the job has to be registered in the AddNCronJob method. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob > ( TimeSpan . FromMinutes ( 5 ), parameterDto ); return Results . Ok (); }); Starting a job at a specific date and time \u00b6 If you want to start a job at a specific date and time, you can use the RunScheduledJob method with a DateTimeOffset as a parameter. The same as before: The job has to be registered. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob > ( new DateTimeOffset ( 2024 , 1 , 1 , 0 , 0 , 0 , TimeSpan . FromHours ( 2 )), parameterDto ); return Results . Ok (); }); Priority \u00b6 Instant jobs are executed with a higher priority than CRON jobs. This means that if you have a CRON job that is scheduled to run at the same time as an instant job, the instant job will be executed first (and if both of them are competing for the same resources, only the instant job will be executed). Force a job run \u00b6 Sometimes you need to run a job immediately, regardless of any running jobs or concurrency settings. The ForceRunInstantJob methods allow you to bypass the job queue and execute a job directly. While regular instant jobs follow the same concurrency rules as CRON jobs, forced jobs ignore these restrictions: public class EmailJob : IJob { private readonly IEmailService emailService ; public EmailJob ( IEmailService emailService ) => this . emailService = emailService ; public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) => emailService . SendEmailAsync (( EmailMessage ) context . Parameter , token ); } // Normal instant job - will wait if another EmailJob is running app . MapPost ( \"/send-email\" , ( EmailMessage msg , IInstantJobRegistry registry ) => { registry . RunInstantJob < EmailJob > ( msg ); return Results . Accepted (); }); // Forced instant job - runs immediately even if other EmailJobs are active app . MapPost ( \"/send-urgent-email\" , ( EmailMessage msg , IInstantJobRegistry registry ) => { registry . ForceRunInstantJob < EmailJob > ( msg ); return Results . Accepted (); }); The force option is also available for scheduled jobs: // Normal scheduled job - follows concurrency rules registry . RunScheduledJob < ReportJob > ( TimeSpan . FromMinutes ( 5 )); // Forced scheduled job - bypasses queue and concurrency limits registry . ForceRunScheduledJob < ReportJob > ( TimeSpan . FromMinutes ( 5 )); Warning Use forced job execution carefully as it bypasses the built-in concurrency protection. This could lead to resource contention if multiple forced jobs run simultaneously. Minimal API \u00b6 Running instant jobs can also be done with the minimal API ( Minimal API ), which allows to create an anonymous lambda, that can also contain dependencies. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob ( async ( HttpClient httpClient ) => { await httpClient . PostAsync ( \"https://api.example.com/send-email\" , new StringContent ( JsonSerializer . Serialize ( parameterDto ))); }); return TypedResults . Ok (); }); Precautions of use \u00b6 Depending of the way jobs are designed and registered, it may happen that NCronJob cannot uniquely identify the intended target of a instant run. In that case, rather than accidently running the wrong job, a runtime exception will be thrown stating that than an ambiguity has been detected. Services . AddNCronJob ( options => { options . AddJob < GatherDataJob > ( s => s . WithCronExpression ( \"0 0 * * *\" )) // Every day at midnight . ExecuteWhen ( success : s => s . RunJob < SendReportToStaffJob > ()); options . AddJob < GatherDataJob > ( s => s . WithCronExpression ( \"0 0 1 * *\" )) // Every first of the month at midnight . ExecuteWhen ( success : s => s . RunJob < SendReportToManagementJob > ()); }); app . MapPost ( \"/on-demand-report\" , ( IInstantJobRegistry registry ) => { registry . RunInstantJob < GatherDataJob > (); // Ambiguous reference. This will throw :-/ return Results . Accepted (); }); Instrumentation \u00b6 All members of the IInstantJobRegistry interface return the correlation id of the triggered job (See \u201cTracing requests of dependencies via CorrelationId \u201c .). Guid oneCorrelationId = jobRegistry . RunInstantJob < MyJob > (); Guid anotherCorrelationId = jobRegistry . RunScheduledJob < MyJob > ( TimeSpan . FromMinutes ( 5 )); [...]","title":"Triggering instant jobs"},{"location":"features/instant-jobs/#triggering-instant-jobs","text":"NCronJob allows you to trigger jobs instantly. This is useful when you want to run a job immediately without waiting for the next scheduled time. For example you get a API request and want to offload the work to a background job immediately. Instant jobs are like \u201cregular\u201d CRON jobs and inherit from IJob . The only difference is that they are triggered manually. So also CRON jobs can be triggered instantly. public class MyJob : IJob { public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { ParameterDto dto = ( ParameterDto ) context . Parameter ; // Do something return Task . CompletedTask ; } } As CRON jobs, they have to be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyJob > (); // No need to specify a CRON expression }); There is no need of a CRON expression for instant jobs. Also passing in parameters doesn\u2019t do anything, they will be passed in differently. Let\u2019s have a look at how to trigger an instant job. Imagine we have a Minimal API where we want to send an E-Mail: app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob < MyJob > ( parameterDto ); return Results . Ok (); }); The RunInstantJob method takes the job type and the parameters as arguments. Optionally you can pass in a CancellationToken as well. The job will be executed immediately.","title":"Triggering instant jobs"},{"location":"features/instant-jobs/#starting-a-job-with-a-delay","text":"If you find the need to delay the execution of an instant job, you can use the RunScheduledJob method with a TimeSpan as a delay. The same as RunInstantJob applies here, the job has to be registered in the AddNCronJob method. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob > ( TimeSpan . FromMinutes ( 5 ), parameterDto ); return Results . Ok (); });","title":"Starting a job with a delay"},{"location":"features/instant-jobs/#starting-a-job-at-a-specific-date-and-time","text":"If you want to start a job at a specific date and time, you can use the RunScheduledJob method with a DateTimeOffset as a parameter. The same as before: The job has to be registered. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob > ( new DateTimeOffset ( 2024 , 1 , 1 , 0 , 0 , 0 , TimeSpan . FromHours ( 2 )), parameterDto ); return Results . Ok (); });","title":"Starting a job at a specific date and time"},{"location":"features/instant-jobs/#priority","text":"Instant jobs are executed with a higher priority than CRON jobs. This means that if you have a CRON job that is scheduled to run at the same time as an instant job, the instant job will be executed first (and if both of them are competing for the same resources, only the instant job will be executed).","title":"Priority"},{"location":"features/instant-jobs/#force-a-job-run","text":"Sometimes you need to run a job immediately, regardless of any running jobs or concurrency settings. The ForceRunInstantJob methods allow you to bypass the job queue and execute a job directly. While regular instant jobs follow the same concurrency rules as CRON jobs, forced jobs ignore these restrictions: public class EmailJob : IJob { private readonly IEmailService emailService ; public EmailJob ( IEmailService emailService ) => this . emailService = emailService ; public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) => emailService . SendEmailAsync (( EmailMessage ) context . Parameter , token ); } // Normal instant job - will wait if another EmailJob is running app . MapPost ( \"/send-email\" , ( EmailMessage msg , IInstantJobRegistry registry ) => { registry . RunInstantJob < EmailJob > ( msg ); return Results . Accepted (); }); // Forced instant job - runs immediately even if other EmailJobs are active app . MapPost ( \"/send-urgent-email\" , ( EmailMessage msg , IInstantJobRegistry registry ) => { registry . ForceRunInstantJob < EmailJob > ( msg ); return Results . Accepted (); }); The force option is also available for scheduled jobs: // Normal scheduled job - follows concurrency rules registry . RunScheduledJob < ReportJob > ( TimeSpan . FromMinutes ( 5 )); // Forced scheduled job - bypasses queue and concurrency limits registry . ForceRunScheduledJob < ReportJob > ( TimeSpan . FromMinutes ( 5 )); Warning Use forced job execution carefully as it bypasses the built-in concurrency protection. This could lead to resource contention if multiple forced jobs run simultaneously.","title":"Force a job run"},{"location":"features/instant-jobs/#minimal-api","text":"Running instant jobs can also be done with the minimal API ( Minimal API ), which allows to create an anonymous lambda, that can also contain dependencies. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob ( async ( HttpClient httpClient ) => { await httpClient . PostAsync ( \"https://api.example.com/send-email\" , new StringContent ( JsonSerializer . Serialize ( parameterDto ))); }); return TypedResults . Ok (); });","title":"Minimal API"},{"location":"features/instant-jobs/#precautions-of-use","text":"Depending of the way jobs are designed and registered, it may happen that NCronJob cannot uniquely identify the intended target of a instant run. In that case, rather than accidently running the wrong job, a runtime exception will be thrown stating that than an ambiguity has been detected. Services . AddNCronJob ( options => { options . AddJob < GatherDataJob > ( s => s . WithCronExpression ( \"0 0 * * *\" )) // Every day at midnight . ExecuteWhen ( success : s => s . RunJob < SendReportToStaffJob > ()); options . AddJob < GatherDataJob > ( s => s . WithCronExpression ( \"0 0 1 * *\" )) // Every first of the month at midnight . ExecuteWhen ( success : s => s . RunJob < SendReportToManagementJob > ()); }); app . MapPost ( \"/on-demand-report\" , ( IInstantJobRegistry registry ) => { registry . RunInstantJob < GatherDataJob > (); // Ambiguous reference. This will throw :-/ return Results . Accepted (); });","title":"Precautions of use"},{"location":"features/instant-jobs/#instrumentation","text":"All members of the IInstantJobRegistry interface return the correlation id of the triggered job (See \u201cTracing requests of dependencies via CorrelationId \u201c .). Guid oneCorrelationId = jobRegistry . RunInstantJob < MyJob > (); Guid anotherCorrelationId = jobRegistry . RunScheduledJob < MyJob > ( TimeSpan . FromMinutes ( 5 )); [...]","title":"Instrumentation"},{"location":"features/minimal-api/","text":"Minimal API \u00b6 The minimal job API offers another way of defining a cron job. It favors simplicity over feature richness. A job can be defined as such: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); This call will register all the necessary services and the job in question. The method can be called multiple times to register multiple jobs: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); builder . Services . AddNCronJob (() => { }, \"1 * * * *\" ); The minimal job API does support resolving services from the DI container. The following example demonstrates how to resolve a logger and a TimeProvider : builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); Also the JobExecutionContext and CancellationToken can be resolved from the DI container: builder . Services . AddNCronJob (( IJobExecutionContext context , CancellationToken token ) => { }, \"*/5 * * * * *\" ); The token can be used to get notified when the job should be cancelled (for example if the whole application gets shut down). Of course functions can be asynchrnous in nature as well: builder . Services . AddNCronJob ( async ( HttpClient httpClient ) => { using var response = await httpClient . GetAsync ( \"https://github.com/NCronJob-Dev/NCronJob\" ); var content = await response . Content . ReadAsStringAsync (); }, \"*/5 * * * * *\" ); There are certain restrictions that can\u2019t be enforced at compile time (due to a missing interface) which will lead to a runtime exception: The job has to return void or Task , otherwise an InvalidOperationException will be thrown. Retry-Support \u00b6 The minimal job API does support the Retry model as well. The minimal job API leverages the fact that lambdas also can have attributes: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] () => { }, \"0 * * * *\" ); To know in which attempt the job currently is, the JobExecutionContext can be used: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] ( IJobExecutionContext context ) => { if ( context . Attempts == 1 ) { // First attempt } }, \"0 * * * *\" ); Time Zone \u00b6 The time zone can be controlled as well and defaults to UTC if not specified: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" , TimeZoneInfo . Local ); Concurrency-Support \u00b6 In the same way, the concurrency level can be controlled (see Concurrency ): builder . Services . AddNCronJob ([ SupportsConcurrency ( 2 )] () => { }, \"0 * * * *\" ); var app = builder . Build (); await app . UseNCronJobAsync (); app . Run (); Now, the job can only be executed by two instances at the same time. Restrictions \u00b6 The minimal API has some restrictions over the \u201cfull approach\u201d: Some errors can only be detected at runtime (for example if the job does not return void or Task ). Minimal API for instant Jobs \u00b6 The minimal API also supports instant jobs, for this check out the Instant Jobs documentation. Minimal API for dependent jobs \u00b6 The minimal API also supports dependent jobs, for this check out the Dependent Jobs documentation.","title":"Minimal API"},{"location":"features/minimal-api/#minimal-api","text":"The minimal job API offers another way of defining a cron job. It favors simplicity over feature richness. A job can be defined as such: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); This call will register all the necessary services and the job in question. The method can be called multiple times to register multiple jobs: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); builder . Services . AddNCronJob (() => { }, \"1 * * * *\" ); The minimal job API does support resolving services from the DI container. The following example demonstrates how to resolve a logger and a TimeProvider : builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); Also the JobExecutionContext and CancellationToken can be resolved from the DI container: builder . Services . AddNCronJob (( IJobExecutionContext context , CancellationToken token ) => { }, \"*/5 * * * * *\" ); The token can be used to get notified when the job should be cancelled (for example if the whole application gets shut down). Of course functions can be asynchrnous in nature as well: builder . Services . AddNCronJob ( async ( HttpClient httpClient ) => { using var response = await httpClient . GetAsync ( \"https://github.com/NCronJob-Dev/NCronJob\" ); var content = await response . Content . ReadAsStringAsync (); }, \"*/5 * * * * *\" ); There are certain restrictions that can\u2019t be enforced at compile time (due to a missing interface) which will lead to a runtime exception: The job has to return void or Task , otherwise an InvalidOperationException will be thrown.","title":"Minimal API"},{"location":"features/minimal-api/#retry-support","text":"The minimal job API does support the Retry model as well. The minimal job API leverages the fact that lambdas also can have attributes: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] () => { }, \"0 * * * *\" ); To know in which attempt the job currently is, the JobExecutionContext can be used: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] ( IJobExecutionContext context ) => { if ( context . Attempts == 1 ) { // First attempt } }, \"0 * * * *\" );","title":"Retry-Support"},{"location":"features/minimal-api/#time-zone","text":"The time zone can be controlled as well and defaults to UTC if not specified: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" , TimeZoneInfo . Local );","title":"Time Zone"},{"location":"features/minimal-api/#concurrency-support","text":"In the same way, the concurrency level can be controlled (see Concurrency ): builder . Services . AddNCronJob ([ SupportsConcurrency ( 2 )] () => { }, \"0 * * * *\" ); var app = builder . Build (); await app . UseNCronJobAsync (); app . Run (); Now, the job can only be executed by two instances at the same time.","title":"Concurrency-Support"},{"location":"features/minimal-api/#restrictions","text":"The minimal API has some restrictions over the \u201cfull approach\u201d: Some errors can only be detected at runtime (for example if the job does not return void or Task ).","title":"Restrictions"},{"location":"features/minimal-api/#minimal-api-for-instant-jobs","text":"The minimal API also supports instant jobs, for this check out the Instant Jobs documentation.","title":"Minimal API for instant Jobs"},{"location":"features/minimal-api/#minimal-api-for-dependent-jobs","text":"The minimal API also supports dependent jobs, for this check out the Dependent Jobs documentation.","title":"Minimal API for dependent jobs"},{"location":"features/model-dependencies/","text":"Model Dependencies \u00b6 This chapter explains how to define jobs that should automatically run based on the completion of other jobs. This feature is useful when you have a series of tasks that must be executed in a specific order allowing to build a pipeline of jobs. Modelling Dependencies with ExecuteWhen \u00b6 In NCronJob , you can define job dependencies using the ExecuteWhen method. This method allows you to specify that a job should run only after another job has completed successfully or faulted. Services . AddNCronJob ( options => { options . AddJob < JobB > (). ExecuteWhen ( success : s => s . RunJob < SuccessJob > (), faulted : f => f . RunJob < FaultedJob > ()); }); Both success and faulted are optional so that you can define only one of them if needed. RunJob can be chained to allow multiple jobs to run after the completion of the main job. This allows very complex job dependencies to be defined in a simple and readable way. Passing parameters to dependent jobs \u00b6 The RunJob method allows optional parameters to be passed to the dependent job. Services . AddNCronJob ( options => { options . AddJob < JobB > (). ExecuteWhen ( success : s => s . RunJob < SuccessJob > ( \"Foo\" )); }); Accessing the state of the parent job \u00b6 The JobExecutionContext object passed to the dependent job contains the output of the parent job. This allows access to the state of the parent job. This can be helpful if information should flow from the parent to the child job. public class JobA : IJob { public Task ExecuteAsync ( IJobExecutionContext context ) { context . Output = \"Hello World\" ; return Task . CompletedTask ; } } public class JobB : IJob { public Task ExecuteAsync ( IJobExecutionContext context ) { var parentOutput = context . ParentOutput ; // \"Hello World\" return Task . CompletedTask ; } } // Register the dependency so that JobB runs after JobA automatically Services . AddNCronJob ( options => { options . AddJob < JobA > (). ExecuteWhen ( success : s => s . RunJob < JobB > ()); }); Order of execution between INotificationJobHandler and dependent jobs \u00b6 If a job has a dependency on another job, the dependent job will run after the INotificationJobHandler has been executed and awaited. Tracing requests of dependencies via CorrelationId \u00b6 Every JobExecutionContext has a CorrelationId property that can be used to trace the execution of dependent jobs. This property is automatically set to the CorrelationId of the parent job and stays the same for all dependent jobs down the chain. Cancelling dependent jobs \u00b6 To actively cancel dependent jobs, the JobExecutionContext object passed offers a SkipChildren method. This method can be called to prevent dependent jobs from running. public class JobA : IJob { public Task ExecuteAsync ( IJobExecutionContext context ) { context . SkipChildren (); return Task . CompletedTask ; } } public class JobB : IJob { public Task ExecuteAsync ( IJobExecutionContext context ) { // This job will not run return Task . CompletedTask ; } } builder . Services . AddNCronJob ( options => { options . AddJob < JobA > (). ExecuteWhen ( success : s => s . RunJob < JobB > ()); }); Minimal API \u00b6 The ExecuteWhen method can also be used in a Minimal API to define job dependencies: builder . Services . AddNCronJob ( options => { options . AddJob < ImportDataJob > (). ExecuteWhen ( success : s => s . RunJob ( async ( ITransfomerService transformerService ) => await transformerService . TransformDataAsync ()), faulted : f => f . RunJob ( async ( INotificationService notificationService ) => await notificationService . SendNotificationAsync ())); }); Getting the parent job\u2019s output in a Minimal API \u00b6 If you pass in a JobExecutionContext to the dependent job, you can access the parent job\u2019s output: builder . Services . AddNCronJob ( options => { options . AddJob < ImportDataJob > (). ExecuteWhen ( success : s => s . RunJob ( async ( IJobExecutionContext context , ITransfomerService transformerService ) => { var parentOutput = ( MyDataModel ) context . ParentOutput ; await transformerService . TransformDataAsync ( parentOutput ); })); }); Defining dependencies for minimal Jobs \u00b6 To define that a job should be executed afterward, you can use the AddJob overload like this: builder . Services . AddNCronJob ( options => { options . AddJob ( async ( IMyService myService ) => await myService . Run ()) . ExecuteWhen ( success : b => b . RunJob (() => Console . Write ( \"Run when successful\" ))); }); Run mutliple jobs after the completion of a job \u00b6 You can run multiple jobs after the completion of a job: Job A -- successful --> Job B |- successful --> Job C Can be achieved in two ways: Services . AddNCronJob ( options => { options . AddJob < JobA > (). ExecuteWhen ( success : s => s . RunJob < JobB > (). RunJob < JobC > ()); }); Or by chaining the ExecuteWhen method: Services . AddNCronJob ( options => { options . AddJob < JobA > () . ExecuteWhen ( success : s => s . RunJob < JobB > ()) . ExecuteWhen ( success : s => s . RunJob < JobC > ()); // Register JobB and JobC into the container to avoid warnings options . AddJob < JobB > (); options . AddJob < JobC > (); }); Note The order of execution of the dependent jobs is not guaranteed. They will not necessarily run in the order of registration. In the example above, it can happen that JobC runs before JobB . If you need to ensure the order of execution, see the next section. Construct complex dependencies \u00b6 You can construct complex dependencies by using a combination of AddJob and ExecuteWhen methods. Here an example: Job A -> Job B -> Job C This can be achieved by: Services . AddNCronJob ( options => { options . AddJob < JobA > (). ExecuteWhen ( success : s => s . RunJob < JobB > () . AddJob < JobB > (). ExecuteWhen ( success : s => s . RunJob < JobC > ()); // Register JobC into the container to avoid warnings options . AddJob < JobC > (); });","title":"Model dependencies"},{"location":"features/model-dependencies/#model-dependencies","text":"This chapter explains how to define jobs that should automatically run based on the completion of other jobs. This feature is useful when you have a series of tasks that must be executed in a specific order allowing to build a pipeline of jobs.","title":"Model Dependencies"},{"location":"features/model-dependencies/#modelling-dependencies-with-executewhen","text":"In NCronJob , you can define job dependencies using the ExecuteWhen method. This method allows you to specify that a job should run only after another job has completed successfully or faulted. Services . AddNCronJob ( options => { options . AddJob < JobB > (). ExecuteWhen ( success : s => s . RunJob < SuccessJob > (), faulted : f => f . RunJob < FaultedJob > ()); }); Both success and faulted are optional so that you can define only one of them if needed. RunJob can be chained to allow multiple jobs to run after the completion of the main job. This allows very complex job dependencies to be defined in a simple and readable way.","title":"Modelling Dependencies with ExecuteWhen"},{"location":"features/model-dependencies/#passing-parameters-to-dependent-jobs","text":"The RunJob method allows optional parameters to be passed to the dependent job. Services . AddNCronJob ( options => { options . AddJob < JobB > (). ExecuteWhen ( success : s => s . RunJob < SuccessJob > ( \"Foo\" )); });","title":"Passing parameters to dependent jobs"},{"location":"features/model-dependencies/#accessing-the-state-of-the-parent-job","text":"The JobExecutionContext object passed to the dependent job contains the output of the parent job. This allows access to the state of the parent job. This can be helpful if information should flow from the parent to the child job. public class JobA : IJob { public Task ExecuteAsync ( IJobExecutionContext context ) { context . Output = \"Hello World\" ; return Task . CompletedTask ; } } public class JobB : IJob { public Task ExecuteAsync ( IJobExecutionContext context ) { var parentOutput = context . ParentOutput ; // \"Hello World\" return Task . CompletedTask ; } } // Register the dependency so that JobB runs after JobA automatically Services . AddNCronJob ( options => { options . AddJob < JobA > (). ExecuteWhen ( success : s => s . RunJob < JobB > ()); });","title":"Accessing the state of the parent job"},{"location":"features/model-dependencies/#order-of-execution-between-inotificationjobhandler-and-dependent-jobs","text":"If a job has a dependency on another job, the dependent job will run after the INotificationJobHandler has been executed and awaited.","title":"Order of execution between INotificationJobHandler and dependent jobs"},{"location":"features/model-dependencies/#tracing-requests-of-dependencies-via-correlationid","text":"Every JobExecutionContext has a CorrelationId property that can be used to trace the execution of dependent jobs. This property is automatically set to the CorrelationId of the parent job and stays the same for all dependent jobs down the chain.","title":"Tracing requests of dependencies via CorrelationId"},{"location":"features/model-dependencies/#cancelling-dependent-jobs","text":"To actively cancel dependent jobs, the JobExecutionContext object passed offers a SkipChildren method. This method can be called to prevent dependent jobs from running. public class JobA : IJob { public Task ExecuteAsync ( IJobExecutionContext context ) { context . SkipChildren (); return Task . CompletedTask ; } } public class JobB : IJob { public Task ExecuteAsync ( IJobExecutionContext context ) { // This job will not run return Task . CompletedTask ; } } builder . Services . AddNCronJob ( options => { options . AddJob < JobA > (). ExecuteWhen ( success : s => s . RunJob < JobB > ()); });","title":"Cancelling dependent jobs"},{"location":"features/model-dependencies/#minimal-api","text":"The ExecuteWhen method can also be used in a Minimal API to define job dependencies: builder . Services . AddNCronJob ( options => { options . AddJob < ImportDataJob > (). ExecuteWhen ( success : s => s . RunJob ( async ( ITransfomerService transformerService ) => await transformerService . TransformDataAsync ()), faulted : f => f . RunJob ( async ( INotificationService notificationService ) => await notificationService . SendNotificationAsync ())); });","title":"Minimal API"},{"location":"features/model-dependencies/#getting-the-parent-jobs-output-in-a-minimal-api","text":"If you pass in a JobExecutionContext to the dependent job, you can access the parent job\u2019s output: builder . Services . AddNCronJob ( options => { options . AddJob < ImportDataJob > (). ExecuteWhen ( success : s => s . RunJob ( async ( IJobExecutionContext context , ITransfomerService transformerService ) => { var parentOutput = ( MyDataModel ) context . ParentOutput ; await transformerService . TransformDataAsync ( parentOutput ); })); });","title":"Getting the parent job&rsquo;s output in a Minimal API"},{"location":"features/model-dependencies/#defining-dependencies-for-minimal-jobs","text":"To define that a job should be executed afterward, you can use the AddJob overload like this: builder . Services . AddNCronJob ( options => { options . AddJob ( async ( IMyService myService ) => await myService . Run ()) . ExecuteWhen ( success : b => b . RunJob (() => Console . Write ( \"Run when successful\" ))); });","title":"Defining dependencies for minimal Jobs"},{"location":"features/model-dependencies/#run-mutliple-jobs-after-the-completion-of-a-job","text":"You can run multiple jobs after the completion of a job: Job A -- successful --> Job B |- successful --> Job C Can be achieved in two ways: Services . AddNCronJob ( options => { options . AddJob < JobA > (). ExecuteWhen ( success : s => s . RunJob < JobB > (). RunJob < JobC > ()); }); Or by chaining the ExecuteWhen method: Services . AddNCronJob ( options => { options . AddJob < JobA > () . ExecuteWhen ( success : s => s . RunJob < JobB > ()) . ExecuteWhen ( success : s => s . RunJob < JobC > ()); // Register JobB and JobC into the container to avoid warnings options . AddJob < JobB > (); options . AddJob < JobC > (); }); Note The order of execution of the dependent jobs is not guaranteed. They will not necessarily run in the order of registration. In the example above, it can happen that JobC runs before JobB . If you need to ensure the order of execution, see the next section.","title":"Run mutliple jobs after the completion of a job"},{"location":"features/model-dependencies/#construct-complex-dependencies","text":"You can construct complex dependencies by using a combination of AddJob and ExecuteWhen methods. Here an example: Job A -> Job B -> Job C This can be achieved by: Services . AddNCronJob ( options => { options . AddJob < JobA > (). ExecuteWhen ( success : s => s . RunJob < JobB > () . AddJob < JobB > (). ExecuteWhen ( success : s => s . RunJob < JobC > ()); // Register JobC into the container to avoid warnings options . AddJob < JobC > (); });","title":"Construct complex dependencies"},{"location":"features/multiple-cron-expressions/","text":"Registering multiple CRON expressions \u00b6 The fluent builder allows you to register multiple CRON expressions for a single job. This is useful when you want to run a job at different times of the day. For example: Services . AddNCronJob ( options => { // Register a job that runs at midnight and midday options . AddJob < ExampleJob > ( j => { j . WithCronExpression ( \"0 0 * * *\" ) // Run at midnight . And . WithCronExpression ( \"0 12 * * *\" ); // Run at midday }); }); The And method is used to chain multiple CRON expressions together. You can chain as many expressions as you like. If a given job has the same CRON expression registered multiple times, it will be executed multiple times as well. Services . AddNCronJob ( options => { // Register a job that runs every 5 minutes options . AddJob < ExampleJob > ( j => { j . WithCronExpression ( \"*/5 * * * *\" ) // Run every 5 minutes . And . WithCronExpression ( \"*/5 * * * *\" ); // Run every 5 minutes }); }); Two instances of the ExampleJob class will be created and executed every 5 minutes.","title":"Registering multiple CRON expressions"},{"location":"features/multiple-cron-expressions/#registering-multiple-cron-expressions","text":"The fluent builder allows you to register multiple CRON expressions for a single job. This is useful when you want to run a job at different times of the day. For example: Services . AddNCronJob ( options => { // Register a job that runs at midnight and midday options . AddJob < ExampleJob > ( j => { j . WithCronExpression ( \"0 0 * * *\" ) // Run at midnight . And . WithCronExpression ( \"0 12 * * *\" ); // Run at midday }); }); The And method is used to chain multiple CRON expressions together. You can chain as many expressions as you like. If a given job has the same CRON expression registered multiple times, it will be executed multiple times as well. Services . AddNCronJob ( options => { // Register a job that runs every 5 minutes options . AddJob < ExampleJob > ( j => { j . WithCronExpression ( \"*/5 * * * *\" ) // Run every 5 minutes . And . WithCronExpression ( \"*/5 * * * *\" ); // Run every 5 minutes }); }); Two instances of the ExampleJob class will be created and executed every 5 minutes.","title":"Registering multiple CRON expressions"},{"location":"features/notifications/","text":"Notifications \u00b6 NCronJob provides a way to get notified when a job is done. For this, implement a IJobNotificationHandler<TJob> and register it in your DI container. builder . Services . AddNCronJob ( options => options . AddCronJob < PrintHelloWorld > ( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }) . AddNotificationHandler < MyJobNotificationHandler > ()); This allows to run logic after a job is done. The JobExecutionContext and the Exception (if there was one) are passed to the Handle method. public class MyJobNotificationHandler : IJobNotificationHandler < MyJob > { private readonly ILogger < MyJobNotificationHandler > logger ; public MyJobNotificationHandler ( ILogger < MyJobNotificationHandler > logger ) { this . logger = logger ; } public Task HandleAsync ( IJobExecutionContext context , Exception ? exception , CancellationToken token ) { if ( exception is not null ) { logger . LogError ( exception , \"Job failed\" ); } else { logger . LogInformation ( \"Job was successful\" ); logger . LogInformation ( \"Output: {Output}\" , context . Output ); } return Task . CompletedTask ; } }","title":"Notifications"},{"location":"features/notifications/#notifications","text":"NCronJob provides a way to get notified when a job is done. For this, implement a IJobNotificationHandler<TJob> and register it in your DI container. builder . Services . AddNCronJob ( options => options . AddCronJob < PrintHelloWorld > ( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }) . AddNotificationHandler < MyJobNotificationHandler > ()); This allows to run logic after a job is done. The JobExecutionContext and the Exception (if there was one) are passed to the Handle method. public class MyJobNotificationHandler : IJobNotificationHandler < MyJob > { private readonly ILogger < MyJobNotificationHandler > logger ; public MyJobNotificationHandler ( ILogger < MyJobNotificationHandler > logger ) { this . logger = logger ; } public Task HandleAsync ( IJobExecutionContext context , Exception ? exception , CancellationToken token ) { if ( exception is not null ) { logger . LogError ( exception , \"Job failed\" ); } else { logger . LogInformation ( \"Job was successful\" ); logger . LogInformation ( \"Output: {Output}\" , context . Output ); } return Task . CompletedTask ; } }","title":"Notifications"},{"location":"features/parameters/","text":"Passing parameters to a job \u00b6 Often a job needs some kind of configuration or parameter to run. Imagine you have a job that generates a report and can run daily, weekly or monthly. You could create three different jobs for each frequency, but that would be a lot of duplicated code. Instead, you can pass in parameters to the job. Services . AddNCronJob ( options => { options . AddJob < ReportJob > ( j => { // Runs every day at midnight and passes in the string \"daily\" j . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"daily\" ) . And . WithCronExpression ( \"0 0 * * 0\" ). WithParameter ( \"weekly\" ) . And . WithCronExpression ( \"0 0 1 * *\" ). WithParameter ( \"monthly\" ); }); }); In the ReportJob you can now access the parameter via the JobExecutionContext : public class ReportJob : IJob { public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var parameter = context . Parameter ; // Do something with the parameter switch ( parameter ) { case \"daily\" : // Generate daily report break ; case \"weekly\" : // Generate weekly report break ; case \"monthly\" : // Generate monthly report break ; } return Task . CompletedTask ; } } Parameters are not immutable \u00b6 Passed in parameters are not immutable by default or cloned throughout the job execution. This means that if you change the parameter in the job, it will also change in the next execution. If you need to keep the parameter unchanged, you should clone it in the job. public class MyParameter { public int Counter { get ; set ; } } Services . AddNCronJob ( b => { b . AddJob < MyJob > ( p => p . WithCronExpression (...)); }); public class MyJob : IJob { public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var myParam = ( MyParameter ) context . Parameter ; myParam . Counter ++ ; // This will be incremented with each job run } } If MyJob runs twice already and is invoked a third time, myParam.Counter will be 2 when the function gets invoked.","title":"Passing Parameters"},{"location":"features/parameters/#passing-parameters-to-a-job","text":"Often a job needs some kind of configuration or parameter to run. Imagine you have a job that generates a report and can run daily, weekly or monthly. You could create three different jobs for each frequency, but that would be a lot of duplicated code. Instead, you can pass in parameters to the job. Services . AddNCronJob ( options => { options . AddJob < ReportJob > ( j => { // Runs every day at midnight and passes in the string \"daily\" j . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"daily\" ) . And . WithCronExpression ( \"0 0 * * 0\" ). WithParameter ( \"weekly\" ) . And . WithCronExpression ( \"0 0 1 * *\" ). WithParameter ( \"monthly\" ); }); }); In the ReportJob you can now access the parameter via the JobExecutionContext : public class ReportJob : IJob { public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var parameter = context . Parameter ; // Do something with the parameter switch ( parameter ) { case \"daily\" : // Generate daily report break ; case \"weekly\" : // Generate weekly report break ; case \"monthly\" : // Generate monthly report break ; } return Task . CompletedTask ; } }","title":"Passing parameters to a job"},{"location":"features/parameters/#parameters-are-not-immutable","text":"Passed in parameters are not immutable by default or cloned throughout the job execution. This means that if you change the parameter in the job, it will also change in the next execution. If you need to keep the parameter unchanged, you should clone it in the job. public class MyParameter { public int Counter { get ; set ; } } Services . AddNCronJob ( b => { b . AddJob < MyJob > ( p => p . WithCronExpression (...)); }); public class MyJob : IJob { public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var myParam = ( MyParameter ) context . Parameter ; myParam . Counter ++ ; // This will be incremented with each job run } } If MyJob runs twice already and is invoked a third time, myParam.Counter will be 2 when the function gets invoked.","title":"Parameters are not immutable"},{"location":"features/retry-support/","text":"Retry Support \u00b6 The new Retry support provides a robust mechanism for handling transient failures by retrying failed operations. This feature is implemented using the RetryPolicy attribute that can be applied to any class implementing the IJob interface. How It Works \u00b6 The RetryPolicy attribute allows you to specify the number of retry attempts and the strategy for handling retries. There are two built-in retry strategies: - ExponentialBackoff: Increases the delay between retry attempts exponentially. - FixedInterval: Keeps the delay between retry attempts consistent. Using Retry Policies \u00b6 Here are examples of how to use the built-in retry policies: Example 1: Basic Retry Policy, defaults to Exponential Backoff \u00b6 [RetryPolicy(retryCount: 4)] public class RetryJob ( ILogger < RetryJob > logger ) : IJob { public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"RetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in RetryJob.\" ); } logger . LogInformation ( $\"RetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } Example 2: Fixed Interval \u00b6 [RetryPolicy(4, PolicyType.FixedInterval)] public class FixedIntervalRetryJob ( ILogger < FixedIntervalRetryJob > logger ) : IJob { public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"FixedIntervalRetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } Advanced: Custom Retry Policies \u00b6 You can also create custom retry policies by implementing the IPolicyCreator interface. This allows you to define complex retry logic tailored to your specific needs. [RetryPolicy<MyCustomPolicyCreator>(retryCount:4, delayFactor:1)] public class CustomPolicyJob ( ILogger < CustomPolicyJob > logger ) : IJob { public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"CustomPolicyJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } public class MyCustomPolicyCreator : IPolicyCreator { public IAsyncPolicy CreatePolicy ( int maxRetryAttempts = 3 , double delayFactor = 2 ) { return Policy . Handle < Exception > () . WaitAndRetryAsync ( maxRetryAttempts , retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( delayFactor , retryAttempt ))); } }","title":"Retry support"},{"location":"features/retry-support/#retry-support","text":"The new Retry support provides a robust mechanism for handling transient failures by retrying failed operations. This feature is implemented using the RetryPolicy attribute that can be applied to any class implementing the IJob interface.","title":"Retry Support"},{"location":"features/retry-support/#how-it-works","text":"The RetryPolicy attribute allows you to specify the number of retry attempts and the strategy for handling retries. There are two built-in retry strategies: - ExponentialBackoff: Increases the delay between retry attempts exponentially. - FixedInterval: Keeps the delay between retry attempts consistent.","title":"How It Works"},{"location":"features/retry-support/#using-retry-policies","text":"Here are examples of how to use the built-in retry policies:","title":"Using Retry Policies"},{"location":"features/retry-support/#example-1-basic-retry-policy-defaults-to-exponential-backoff","text":"[RetryPolicy(retryCount: 4)] public class RetryJob ( ILogger < RetryJob > logger ) : IJob { public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"RetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in RetryJob.\" ); } logger . LogInformation ( $\"RetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } }","title":"Example 1: Basic Retry Policy, defaults to Exponential Backoff"},{"location":"features/retry-support/#example-2-fixed-interval","text":"[RetryPolicy(4, PolicyType.FixedInterval)] public class FixedIntervalRetryJob ( ILogger < FixedIntervalRetryJob > logger ) : IJob { public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"FixedIntervalRetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } }","title":"Example 2: Fixed Interval"},{"location":"features/retry-support/#advanced-custom-retry-policies","text":"You can also create custom retry policies by implementing the IPolicyCreator interface. This allows you to define complex retry logic tailored to your specific needs. [RetryPolicy<MyCustomPolicyCreator>(retryCount:4, delayFactor:1)] public class CustomPolicyJob ( ILogger < CustomPolicyJob > logger ) : IJob { public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"CustomPolicyJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } public class MyCustomPolicyCreator : IPolicyCreator { public IAsyncPolicy CreatePolicy ( int maxRetryAttempts = 3 , double delayFactor = 2 ) { return Policy . Handle < Exception > () . WaitAndRetryAsync ( maxRetryAttempts , retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( delayFactor , retryAttempt ))); } }","title":"Advanced: Custom Retry Policies"},{"location":"features/startup-jobs/","text":"Running Startup Jobs \u00b6 NCronJob allows you to configure jobs to run at application startup. This is useful for tasks that need to be executed immediately when the application starts, such as initial data loading, cleanup tasks, or other setup procedures. Startup jobs are defined like regular CRON jobs and inherit from IJob . The only difference is that they are configured to run at startup. All startup jobs must be completed prior to the start of any other CRON (or instant) jobs. public class MyStartupJob : IJob { public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { // Perform startup task return Task . CompletedTask ; } } As with CRON jobs, they must be registered in the AddNCronJob method. builder . Services . AddNCronJob ( options => { options . AddJob < MyStartupJob > () . RunAtStartup (); // Configure the job to run at startup }); var app = builder . Build (); // Execute all startup jobs await app . UseNCronJobAsync (); app . Run (); The RunAtStartup in combination with UseNCronJobAsync method ensures that the job is executed as soon as the application starts. This method is useful for scenarios where certain tasks need to be performed immediately upon application launch. Failure to call UseNCronJobAsync when startup jobs are defined will lead to a fatal exception during the application start. Of course, the call to RunAtStartup can also be chained to the registration of a standard CRON job. This setup may be useful, for instance, when one wants to prime a cache before the application starts, and then regularly refresh its content. It may happen that the specified startup job runs task that are required for the application setup. For those cases, when one cannot tolerate a startup job to fail, the RunAtStartup method accepts an optional parameter shouldCrashOnFailure . When set to true , the specified job is expected to complete in a successful state. Otherwise, an exception will be thrown preventing the application start. Example Use Case \u00b6 Consider an application that needs to load initial data from a database or perform some cleanup tasks whenever it starts. You can define and configure a startup job to handle this: Job Definition \u00b6 public class InitialDataLoader : IJob { private readonly IDataService _dataService ; public InitialDataLoader ( IDataService dataService ) { _dataService = dataService ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { await _dataService . LoadInitialDataAsync (); } } Registering the Job \u00b6 In your Program.cs or Startup.cs file, register the job and configure it to run at startup: builder . Services . AddNCronJob ( options => { options . AddJob < InitialDataLoader > () . RunAtStartup ( shouldCrashOnFailure : true ); }); This setup ensures that: - The InitialDataLoader job will be executed as soon as the application starts, loading the necessary initial data. - Would anything prevent the job to successfully complete, the application will fail to start. Summary \u00b6 Startup jobs are a powerful feature of NCronJob that enable you to execute critical tasks immediately before application startup. By using the RunAtStartup method, you can ensure that your application performs necessary setup procedures, data loading, or cleanup tasks right at the beginning of its lifecycle. This feature is particularly useful for applications that require certain operations to be completed before they are fully functional. By configuring startup jobs, you can streamline your application\u2019s initialization process and improve its overall reliability and performance.","title":"Startup Jobs"},{"location":"features/startup-jobs/#running-startup-jobs","text":"NCronJob allows you to configure jobs to run at application startup. This is useful for tasks that need to be executed immediately when the application starts, such as initial data loading, cleanup tasks, or other setup procedures. Startup jobs are defined like regular CRON jobs and inherit from IJob . The only difference is that they are configured to run at startup. All startup jobs must be completed prior to the start of any other CRON (or instant) jobs. public class MyStartupJob : IJob { public Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { // Perform startup task return Task . CompletedTask ; } } As with CRON jobs, they must be registered in the AddNCronJob method. builder . Services . AddNCronJob ( options => { options . AddJob < MyStartupJob > () . RunAtStartup (); // Configure the job to run at startup }); var app = builder . Build (); // Execute all startup jobs await app . UseNCronJobAsync (); app . Run (); The RunAtStartup in combination with UseNCronJobAsync method ensures that the job is executed as soon as the application starts. This method is useful for scenarios where certain tasks need to be performed immediately upon application launch. Failure to call UseNCronJobAsync when startup jobs are defined will lead to a fatal exception during the application start. Of course, the call to RunAtStartup can also be chained to the registration of a standard CRON job. This setup may be useful, for instance, when one wants to prime a cache before the application starts, and then regularly refresh its content. It may happen that the specified startup job runs task that are required for the application setup. For those cases, when one cannot tolerate a startup job to fail, the RunAtStartup method accepts an optional parameter shouldCrashOnFailure . When set to true , the specified job is expected to complete in a successful state. Otherwise, an exception will be thrown preventing the application start.","title":"Running Startup Jobs"},{"location":"features/startup-jobs/#example-use-case","text":"Consider an application that needs to load initial data from a database or perform some cleanup tasks whenever it starts. You can define and configure a startup job to handle this:","title":"Example Use Case"},{"location":"features/startup-jobs/#job-definition","text":"public class InitialDataLoader : IJob { private readonly IDataService _dataService ; public InitialDataLoader ( IDataService dataService ) { _dataService = dataService ; } public async Task RunAsync ( IJobExecutionContext context , CancellationToken token ) { await _dataService . LoadInitialDataAsync (); } }","title":"Job Definition"},{"location":"features/startup-jobs/#registering-the-job","text":"In your Program.cs or Startup.cs file, register the job and configure it to run at startup: builder . Services . AddNCronJob ( options => { options . AddJob < InitialDataLoader > () . RunAtStartup ( shouldCrashOnFailure : true ); }); This setup ensures that: - The InitialDataLoader job will be executed as soon as the application starts, loading the necessary initial data. - Would anything prevent the job to successfully complete, the application will fail to start.","title":"Registering the Job"},{"location":"features/startup-jobs/#summary","text":"Startup jobs are a powerful feature of NCronJob that enable you to execute critical tasks immediately before application startup. By using the RunAtStartup method, you can ensure that your application performs necessary setup procedures, data loading, or cleanup tasks right at the beginning of its lifecycle. This feature is particularly useful for applications that require certain operations to be completed before they are fully functional. By configuring startup jobs, you can streamline your application\u2019s initialization process and improve its overall reliability and performance.","title":"Summary"},{"location":"migration/v2/","text":"v2 Migration Guide \u00b6 This document will describe the changes made in v2 of NCronJob and how to migrate from v1 . Version 2 of NCronJob brings some breaking changes to make a better API. CronExpression moved towards builder \u00b6 In v1 one would define as such: services . AddNCronJob (); services . AddCronJob < PrintHelloWorld > ( options => { options . CronExpression = \"* * * * *\" ; options . Parameter = \"Hello World\" ; }); With v2 the CronExpression is moved towards the builder pattern and AddCronJob is merged into AddNCronJob : Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld > ( j => { j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }); }); This allows to easily define multiple jobs without adding much boilerplate code. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld > ( p => p . WithCronExpression ( \"0 * * * *\" ). WithParameter ( \"Foo\" ) . And . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"Bar\" )); });","title":"v2 Migration Guide"},{"location":"migration/v2/#v2-migration-guide","text":"This document will describe the changes made in v2 of NCronJob and how to migrate from v1 . Version 2 of NCronJob brings some breaking changes to make a better API.","title":"v2 Migration Guide"},{"location":"migration/v2/#cronexpression-moved-towards-builder","text":"In v1 one would define as such: services . AddNCronJob (); services . AddCronJob < PrintHelloWorld > ( options => { options . CronExpression = \"* * * * *\" ; options . Parameter = \"Hello World\" ; }); With v2 the CronExpression is moved towards the builder pattern and AddCronJob is merged into AddNCronJob : Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld > ( j => { j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }); }); This allows to easily define multiple jobs without adding much boilerplate code. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld > ( p => p . WithCronExpression ( \"0 * * * *\" ). WithParameter ( \"Foo\" ) . And . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"Bar\" )); });","title":"CronExpression moved towards builder"},{"location":"migration/v3/","text":"v3 Migration Guide \u00b6 This document describes the changes made in v3 of NCronJob and how to migrate from v2 . Version 3 of NCronJob introduces some breaking changes to improve the API. Second precision is automatically inferred \u00b6 In v2 one would define as such: builder . Services . AddNCronJob ( n => n . AddJob < SimpleJob > ( p => p . WithCronExpression ( \"* * * * * *\" , true ))); Inside WithCronExpression , there was an optional parameter that, if set to true , required the cron expression to be in seconds precision. This was a bit confusing and not very intuitive. In v3 the seconds precision is automatically inferred. Therefore, the above code can be simplified to: builder . Services . AddNCronJob ( n => n . AddJob < SimpleJob > ( p => p . WithCronExpression ( \"* * * * * *\" ))); JobExecutionContext is now IJobExecutionContext \u00b6 The JobExecutionContext class is no longer used. It has been replaced by the IJobExecutionContext interface. This change was made to allow for easier testing and mocking of the context. Until now you always had to pass in a valid instance which was a bit cumbersome. Now you can mock the interface (or provide a fake) and pass it in. For the migration, you just have to change the type of the parameter in your job from JobExecutionContext to IJobExecutionContext : - public Task RunAsync(JobExecutionContext context, CancellationToken token) + public Task RunAsync(IJobExecutionContext context, CancellationToken token) All the public members are still the same as before. AddNotificationHandler<TJobNotificationHandler, TJobDefinition>() was removed \u00b6 The AddNotificationHandler<TJobNotificationHandler, TJobDefinition>() method was removed. This method was used to add a notification handler for a specific job. It was marked as obsolete and entirely removed after v3.2 . It can be replaced with the AddNotificationHandler<TJobNotificationHandler>() method.","title":"v3 Migration Guide"},{"location":"migration/v3/#v3-migration-guide","text":"This document describes the changes made in v3 of NCronJob and how to migrate from v2 . Version 3 of NCronJob introduces some breaking changes to improve the API.","title":"v3 Migration Guide"},{"location":"migration/v3/#second-precision-is-automatically-inferred","text":"In v2 one would define as such: builder . Services . AddNCronJob ( n => n . AddJob < SimpleJob > ( p => p . WithCronExpression ( \"* * * * * *\" , true ))); Inside WithCronExpression , there was an optional parameter that, if set to true , required the cron expression to be in seconds precision. This was a bit confusing and not very intuitive. In v3 the seconds precision is automatically inferred. Therefore, the above code can be simplified to: builder . Services . AddNCronJob ( n => n . AddJob < SimpleJob > ( p => p . WithCronExpression ( \"* * * * * *\" )));","title":"Second precision is automatically inferred"},{"location":"migration/v3/#jobexecutioncontext-is-now-ijobexecutioncontext","text":"The JobExecutionContext class is no longer used. It has been replaced by the IJobExecutionContext interface. This change was made to allow for easier testing and mocking of the context. Until now you always had to pass in a valid instance which was a bit cumbersome. Now you can mock the interface (or provide a fake) and pass it in. For the migration, you just have to change the type of the parameter in your job from JobExecutionContext to IJobExecutionContext : - public Task RunAsync(JobExecutionContext context, CancellationToken token) + public Task RunAsync(IJobExecutionContext context, CancellationToken token) All the public members are still the same as before.","title":"JobExecutionContext is now IJobExecutionContext"},{"location":"migration/v3/#addnotificationhandlertjobnotificationhandler-tjobdefinition-was-removed","text":"The AddNotificationHandler<TJobNotificationHandler, TJobDefinition>() method was removed. This method was used to add a notification handler for a specific job. It was marked as obsolete and entirely removed after v3.2 . It can be replaced with the AddNotificationHandler<TJobNotificationHandler>() method.","title":"AddNotificationHandler&lt;TJobNotificationHandler, TJobDefinition&gt;() was removed"},{"location":"migration/v4/","text":"v4 Migration Guide \u00b6 This document describes the changes made in v4 of NCronJob and how to migrate from v3 . Version 4 of NCronJob introduces some breaking changes to improve the API. UseNCronJob and UseNCronJobAsync methods \u00b6 Following the classical ASP.NET pattern, the UseNCronJob and UseNCronJobAsync methods have been introduced to the IHost interface. The minimal setup now looks like this: var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddNCronJob (...); var app = builder . Build (); await app . UseNCronJobAsync (); app . Run (); Instead of the async method UseNCronJobAsync , you can also use the synchronous UseNCronJob method. The difference is that the async method returns a Task that you can await. RunAtStartup method \u00b6 The RunAtStartup method has a bit different semantics than before. All startup jobs are now executed when UseNCronJob or UseNCronJobAsync is called. This ensures that all startup jobs are completed before any other part of the application is executed. AddNCronJob(Delegate) move to NCronJobExtensions \u00b6 The AddNCronJob(Delegate) (Minimal API) was a different static class than the AddNCronJob(Action) version. This has been fixed by moving the AddNCronJob(Delegate) method to the NCronJobExtensions class. As most developers are not invoking those extensions via the static class, this should not affect most users. Otherwise the migration is simple: - IServiceCollection.AddNCronJob(() => {}, \"* * * * *\"); + NCronJobExtensions.AddNCronJob(services, () => {}, \"* * * * *\"); IRuntimeRegistry is more restrictive \u00b6 In v3 the IRuntimeRegistry offered the ability to use the whole NCronJobOptionBuilder which led to confusion, especially if done something like this: runtimeRegistry . AddJob ( n => n . AddJob < MyJob > (...). RunAtStartup (). AddExceptionHandler < MyHandler > ()); It didn\u2019t make sense to add a startup job during runtime. Also adding exception handlers during runtime was out of scope for this feature. Therefore the interface is more restrictive now and only allows to add jobs. IRuntimeRegistry s AddJob is now called TryRegister \u00b6 The AddJob method of the IRuntimeRegistry has been renamed to Register to better reflect its purpose and to avoid the convoluted naming. - runtimeRegistry.AddJob(r => r.AddJob); + runtimeRegistry.TryRegister(r => r.AddJob); Not only that there is another overload: + runtimeRegistry . TryRegister ( r => r . AddJob , out Exception ? exc ); The new TryRegister method returns a boolean indicating if the registration was successful and an exception if the registration failed. This can happen if the same configuration of a job is already configured (like same job type, with same cron expression and parameter). Chaining was removed \u00b6 Additionally, the chaining of the former Add (now TryRegister ) method was removed. If the first job registration was successful, but the second failed, the first job was still registered. This seemed arbitrary and was removed. Each chain should be its own TryRegister call now. Registering duplicated jobs will lead to an exception during startup \u00b6 Given the following job registration: builder . Services . AddNCronJob ( r => r . AddJob < MyJob > ( p => p . WithCronExpression ( \"* * * * *\" ) . And . WithCronExpression ( \"* * * * *\" ))); In v3 and earlier the second registration would have been ignored. In v4 this will lead to an exception. This is to prevent accidental misconfigurations. Especially because jobs, by default, are not executed in parallel without further configuration. If you want to register the same job multiple times, you can define a custom name for the job: builder . Services . AddNCronJob ( r => r . AddJob < MyJob > ( p => p . WithCronExpression ( \"* * * * *\" ) . And . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyJob\" )));","title":"v4 Migration Guide"},{"location":"migration/v4/#v4-migration-guide","text":"This document describes the changes made in v4 of NCronJob and how to migrate from v3 . Version 4 of NCronJob introduces some breaking changes to improve the API.","title":"v4 Migration Guide"},{"location":"migration/v4/#usencronjob-and-usencronjobasync-methods","text":"Following the classical ASP.NET pattern, the UseNCronJob and UseNCronJobAsync methods have been introduced to the IHost interface. The minimal setup now looks like this: var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddNCronJob (...); var app = builder . Build (); await app . UseNCronJobAsync (); app . Run (); Instead of the async method UseNCronJobAsync , you can also use the synchronous UseNCronJob method. The difference is that the async method returns a Task that you can await.","title":"UseNCronJob and UseNCronJobAsync methods"},{"location":"migration/v4/#runatstartup-method","text":"The RunAtStartup method has a bit different semantics than before. All startup jobs are now executed when UseNCronJob or UseNCronJobAsync is called. This ensures that all startup jobs are completed before any other part of the application is executed.","title":"RunAtStartup method"},{"location":"migration/v4/#addncronjobdelegate-move-to-ncronjobextensions","text":"The AddNCronJob(Delegate) (Minimal API) was a different static class than the AddNCronJob(Action) version. This has been fixed by moving the AddNCronJob(Delegate) method to the NCronJobExtensions class. As most developers are not invoking those extensions via the static class, this should not affect most users. Otherwise the migration is simple: - IServiceCollection.AddNCronJob(() => {}, \"* * * * *\"); + NCronJobExtensions.AddNCronJob(services, () => {}, \"* * * * *\");","title":"AddNCronJob(Delegate) move to NCronJobExtensions"},{"location":"migration/v4/#iruntimeregistry-is-more-restrictive","text":"In v3 the IRuntimeRegistry offered the ability to use the whole NCronJobOptionBuilder which led to confusion, especially if done something like this: runtimeRegistry . AddJob ( n => n . AddJob < MyJob > (...). RunAtStartup (). AddExceptionHandler < MyHandler > ()); It didn\u2019t make sense to add a startup job during runtime. Also adding exception handlers during runtime was out of scope for this feature. Therefore the interface is more restrictive now and only allows to add jobs.","title":"IRuntimeRegistry is more restrictive"},{"location":"migration/v4/#iruntimeregistrys-addjob-is-now-called-tryregister","text":"The AddJob method of the IRuntimeRegistry has been renamed to Register to better reflect its purpose and to avoid the convoluted naming. - runtimeRegistry.AddJob(r => r.AddJob); + runtimeRegistry.TryRegister(r => r.AddJob); Not only that there is another overload: + runtimeRegistry . TryRegister ( r => r . AddJob , out Exception ? exc ); The new TryRegister method returns a boolean indicating if the registration was successful and an exception if the registration failed. This can happen if the same configuration of a job is already configured (like same job type, with same cron expression and parameter).","title":"IRuntimeRegistrys AddJob is now called TryRegister"},{"location":"migration/v4/#chaining-was-removed","text":"Additionally, the chaining of the former Add (now TryRegister ) method was removed. If the first job registration was successful, but the second failed, the first job was still registered. This seemed arbitrary and was removed. Each chain should be its own TryRegister call now.","title":"Chaining was removed"},{"location":"migration/v4/#registering-duplicated-jobs-will-lead-to-an-exception-during-startup","text":"Given the following job registration: builder . Services . AddNCronJob ( r => r . AddJob < MyJob > ( p => p . WithCronExpression ( \"* * * * *\" ) . And . WithCronExpression ( \"* * * * *\" ))); In v3 and earlier the second registration would have been ignored. In v4 this will lead to an exception. This is to prevent accidental misconfigurations. Especially because jobs, by default, are not executed in parallel without further configuration. If you want to register the same job multiple times, you can define a custom name for the job: builder . Services . AddNCronJob ( r => r . AddJob < MyJob > ( p => p . WithCronExpression ( \"* * * * *\" ) . And . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyJob\" )));","title":"Registering duplicated jobs will lead to an exception during startup"}]}