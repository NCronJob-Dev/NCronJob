{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NCronJob \u00b6 A Job Scheduler sitting on top of IHostedService in dotnet. Often times one finds themself between the simplicity of the BackgroundService / IHostedService and the complexity of a full-blown Hangfire or Quartz scheduler. This library aims to fill that gap by providing a simple and easy to use job scheduler that can be used in any dotnet application and feels \u201cnative\u201d. So no need for setting up a database, just schedule your stuff right away! The library gives you two ways of scheduling jobs: Instant jobs - just run a job right away (or with a small delay; or with a given date and time) Cron jobs - schedule a job using a cron expression This library is possible because of these wonderful people: If you want to support this project, you can: Leave a star \u2b50\ufe0f If you find issues, report them to us: https://github.com/NCronJob-Dev/NCronJob/issues If you have a feature request, let us know: https://github.com/NCronJob-Dev/NCronJob/issues","title":"NCronJob"},{"location":"#ncronjob","text":"A Job Scheduler sitting on top of IHostedService in dotnet. Often times one finds themself between the simplicity of the BackgroundService / IHostedService and the complexity of a full-blown Hangfire or Quartz scheduler. This library aims to fill that gap by providing a simple and easy to use job scheduler that can be used in any dotnet application and feels \u201cnative\u201d. So no need for setting up a database, just schedule your stuff right away! The library gives you two ways of scheduling jobs: Instant jobs - just run a job right away (or with a small delay; or with a given date and time) Cron jobs - schedule a job using a cron expression This library is possible because of these wonderful people: If you want to support this project, you can: Leave a star \u2b50\ufe0f If you find issues, report them to us: https://github.com/NCronJob-Dev/NCronJob/issues If you have a feature request, let us know: https://github.com/NCronJob-Dev/NCronJob/issues","title":"NCronJob"},{"location":"getting-started/","text":"Getting Started \u00b6 Using NCronJob is simple and easy. Just follow the steps below to get started. 1. Install the package \u00b6 Install the latest stable version of the package via NuGet: dotnet add package NCronJob Alternatively add the package reference to your .csproj file: <PackageReference Include= \"NCronJob\" Version= \"2.8.2\" /> 2. Create a job \u00b6 NCronJob offers a single way of defining jobs: by implementing the IJob interface with a single RunAsync method: public class PrintHelloWorld : IJob { private readonly ILogger < PrintHelloWorld > logger ; public PrintHelloWorld ( ILogger < PrintHelloWorld > logger ) { this . logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( \"Hello World\" ); logger . LogInformation ( \"Parameter: {Parameter}\" , context . Parameter ); return Task . CompletedTask ; } } 3. Register the service and the job \u00b6 The NCronJob library provides one easy entry point for all its magic, the AddNCronJob extension method on top of the IServiceCollection interface. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); })); }); Now your PrintHelloWorld job will run every minute and log \u201cHello World\u201d to the console. And that is all! Too complicated? \u00b6 We also over a \u201cMinimal API\u201d that allows you to define jobs similiar to the Minimal API for Controllers. builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); The job will be defined \u201cinline\u201d and is capable of resolving services from the DI container. You can read more about this in the section Minimal API .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Using NCronJob is simple and easy. Just follow the steps below to get started.","title":"Getting Started"},{"location":"getting-started/#1-install-the-package","text":"Install the latest stable version of the package via NuGet: dotnet add package NCronJob Alternatively add the package reference to your .csproj file: <PackageReference Include= \"NCronJob\" Version= \"2.8.2\" />","title":"1. Install the package"},{"location":"getting-started/#2-create-a-job","text":"NCronJob offers a single way of defining jobs: by implementing the IJob interface with a single RunAsync method: public class PrintHelloWorld : IJob { private readonly ILogger < PrintHelloWorld > logger ; public PrintHelloWorld ( ILogger < PrintHelloWorld > logger ) { this . logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( \"Hello World\" ); logger . LogInformation ( \"Parameter: {Parameter}\" , context . Parameter ); return Task . CompletedTask ; } }","title":"2. Create a job"},{"location":"getting-started/#3-register-the-service-and-the-job","text":"The NCronJob library provides one easy entry point for all its magic, the AddNCronJob extension method on top of the IServiceCollection interface. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); })); }); Now your PrintHelloWorld job will run every minute and log \u201cHello World\u201d to the console. And that is all!","title":"3. Register the service and the job"},{"location":"getting-started/#too-complicated","text":"We also over a \u201cMinimal API\u201d that allows you to define jobs similiar to the Minimal API for Controllers. builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); The job will be defined \u201cinline\u201d and is capable of resolving services from the DI container. You can read more about this in the section Minimal API .","title":"Too complicated?"},{"location":"advanced/dynamic-job-control/","text":"Dynamic Job Control \u00b6 NCronJob allows you to dynmically add or remove CRON jobs from the scheduler. This is useful when you want to add jobs at runtime or remove jobs based on some condition without restarting the scheduler. Defining job names \u00b6 The core idea is to define an unique job name for each job that might be mutated during runtime. The job name is an optional parameter: builder . Services . AddNCronJob ( builder => { builder . AddJob < SampleJob >( p => p . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyName\" )); }); The same applies to Minimal API: builder . Services . AddNCronJob ( b => b . AddJob (() => {}, \"* * * * *\" , \"MyName)); Job Names \u00b6 Every recurring job (CRON job) can have a unique job name that identifies the job. Job names have to be unique across all jobs that were given a name. If a job is added without a name, it will not be possible to remove or update the job at runtime by name. Adding jobs \u00b6 To add a job at runtime, leverage the IRuntimeJobRegistry interface: app . MapPost ( \"/add-job\" , ( IRuntimeJobRegistry registry ) => { registry . AddJob ( n => n . AddJob < SampleJob >( p => p . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyName\" ))); return TypedResults . Ok (); }); The outer AddJob accepts a builder just like builder.Services.AddNCronJob does. The inner AddJob is the one that actually adds the job to the scheduler and does behave exactly the same. Removing jobs \u00b6 There are two ways to remove a job from the scheduler. By name or by type. To remove a job by name: app . MapDelete ( \"/remove-job\" , ( IRuntimeJobRegistry registry ) => { registry . RemoveJob ( \"MyName\" ); return TypedResults . Ok (); }); That will remove one job from the scheduler that has the name MyName . In contrast removing by type will remove all jobs of the given type (so zero to many jobs): app . MapDelete ( \"/remove-job\" , ( IRuntimeJobRegistry registry ) => { registry . RemoveJob < SampleJob >(); // Alternatively RemoveJob(typeof(SampleJob)) return TypedResults . Ok (); }); Updating the job schedule \u00b6 Updating the job schedule is done via the UpdateSchedule method. This method accepts a job name, a new CRON expression and optionally the time zone: app . MapPut ( \"/update-job\" , ( IRuntimeJobRegistry registry ) => { registry . UpdateSchedule ( \"MyName\" , \"* * * * *\" , TimeZoneInfo . Utc ); return TypedResults . Ok (); }); Updating a schedule will lead to the job being rescheduled with the new CRON expression. Any planned job with the \u201cold\u201d schedule will be cancelled and rescheduled with the new schedule. Updating the parameter \u00b6 Updating the parameter of a job is done via the UpdateParameter method. This method accepts a job name and a new parameter: app . MapPut ( \"/update-job\" , ( IRuntimeJobRegistry registry ) => { registry . UpdateParameter ( \"MyName\" , new MyParameter ()); return TypedResults . Ok (); }); Updating a parameter will lead to the job being rescheduled with the new parameter. Any planned job with the \u201cold\u201d parameter will be cancelled and rescheduled with the new parameter. Retrieving a job schedule by name \u00b6 To retrieve the schedule of a job by name, use the TryGetSchedule method: var found = registry . TryGetSchedule ( \"MyName\" , out string? cronExpression , out TimeZoneInfo ? timeZone ); The cron expression and time zone can be null even if the job was found. This indicates that the job has no schedule (like dependent jobs). Disabling and enabling jobs \u00b6 To disable a job, use the DisableJob method: app . MapPut ( \"/disable-job\" , ( IRuntimeJobRegistry registry ) => { registry . DisableJob ( \"MyName\" ); return TypedResults . Ok (); }); If a job is disabled, it will not be scheduled anymore. Any planned job will be cancelled and the job will be removed from the scheduler. To enable a job, use the EnableJob method: app . MapPut ( \"/enable-job\" , ( IRuntimeJobRegistry registry ) => { registry . EnableJob ( \"MyName\" ); return TypedResults . Ok (); });","title":"Dynamic Job Control"},{"location":"advanced/dynamic-job-control/#dynamic-job-control","text":"NCronJob allows you to dynmically add or remove CRON jobs from the scheduler. This is useful when you want to add jobs at runtime or remove jobs based on some condition without restarting the scheduler.","title":"Dynamic Job Control"},{"location":"advanced/dynamic-job-control/#defining-job-names","text":"The core idea is to define an unique job name for each job that might be mutated during runtime. The job name is an optional parameter: builder . Services . AddNCronJob ( builder => { builder . AddJob < SampleJob >( p => p . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyName\" )); }); The same applies to Minimal API: builder . Services . AddNCronJob ( b => b . AddJob (() => {}, \"* * * * *\" , \"MyName));","title":"Defining job names"},{"location":"advanced/dynamic-job-control/#job-names","text":"Every recurring job (CRON job) can have a unique job name that identifies the job. Job names have to be unique across all jobs that were given a name. If a job is added without a name, it will not be possible to remove or update the job at runtime by name.","title":"Job Names"},{"location":"advanced/dynamic-job-control/#adding-jobs","text":"To add a job at runtime, leverage the IRuntimeJobRegistry interface: app . MapPost ( \"/add-job\" , ( IRuntimeJobRegistry registry ) => { registry . AddJob ( n => n . AddJob < SampleJob >( p => p . WithCronExpression ( \"* * * * *\" ). WithName ( \"MyName\" ))); return TypedResults . Ok (); }); The outer AddJob accepts a builder just like builder.Services.AddNCronJob does. The inner AddJob is the one that actually adds the job to the scheduler and does behave exactly the same.","title":"Adding jobs"},{"location":"advanced/dynamic-job-control/#removing-jobs","text":"There are two ways to remove a job from the scheduler. By name or by type. To remove a job by name: app . MapDelete ( \"/remove-job\" , ( IRuntimeJobRegistry registry ) => { registry . RemoveJob ( \"MyName\" ); return TypedResults . Ok (); }); That will remove one job from the scheduler that has the name MyName . In contrast removing by type will remove all jobs of the given type (so zero to many jobs): app . MapDelete ( \"/remove-job\" , ( IRuntimeJobRegistry registry ) => { registry . RemoveJob < SampleJob >(); // Alternatively RemoveJob(typeof(SampleJob)) return TypedResults . Ok (); });","title":"Removing jobs"},{"location":"advanced/dynamic-job-control/#updating-the-job-schedule","text":"Updating the job schedule is done via the UpdateSchedule method. This method accepts a job name, a new CRON expression and optionally the time zone: app . MapPut ( \"/update-job\" , ( IRuntimeJobRegistry registry ) => { registry . UpdateSchedule ( \"MyName\" , \"* * * * *\" , TimeZoneInfo . Utc ); return TypedResults . Ok (); }); Updating a schedule will lead to the job being rescheduled with the new CRON expression. Any planned job with the \u201cold\u201d schedule will be cancelled and rescheduled with the new schedule.","title":"Updating the job schedule"},{"location":"advanced/dynamic-job-control/#updating-the-parameter","text":"Updating the parameter of a job is done via the UpdateParameter method. This method accepts a job name and a new parameter: app . MapPut ( \"/update-job\" , ( IRuntimeJobRegistry registry ) => { registry . UpdateParameter ( \"MyName\" , new MyParameter ()); return TypedResults . Ok (); }); Updating a parameter will lead to the job being rescheduled with the new parameter. Any planned job with the \u201cold\u201d parameter will be cancelled and rescheduled with the new parameter.","title":"Updating the parameter"},{"location":"advanced/dynamic-job-control/#retrieving-a-job-schedule-by-name","text":"To retrieve the schedule of a job by name, use the TryGetSchedule method: var found = registry . TryGetSchedule ( \"MyName\" , out string? cronExpression , out TimeZoneInfo ? timeZone ); The cron expression and time zone can be null even if the job was found. This indicates that the job has no schedule (like dependent jobs).","title":"Retrieving a job schedule by name"},{"location":"advanced/dynamic-job-control/#disabling-and-enabling-jobs","text":"To disable a job, use the DisableJob method: app . MapPut ( \"/disable-job\" , ( IRuntimeJobRegistry registry ) => { registry . DisableJob ( \"MyName\" ); return TypedResults . Ok (); }); If a job is disabled, it will not be scheduled anymore. Any planned job will be cancelled and the job will be removed from the scheduler. To enable a job, use the EnableJob method: app . MapPut ( \"/enable-job\" , ( IRuntimeJobRegistry registry ) => { registry . EnableJob ( \"MyName\" ); return TypedResults . Ok (); });","title":"Disabling and enabling jobs"},{"location":"advanced/global-concurrency/","text":"Global Concurrency \u00b6 NCronJob utilisies a priority queue with a maximum amount of entries. That is, the queue will only hold and execute a maximum amount of jobs at any given time. This is to prevent the system from being overloaded with jobs. The Maxmimum \u00b6 The global maximum of concurrent jobs is calculated as: var maxDegreeOfParallelism = Environment . ProcessorCount * 4 ; If you have a CPU with 12 Cores (like a M2 Processor), the maximum amount of concurrent jobs will be 48. A CRON job is rescheduled after it has been executed. This means that the queue will always be filled with jobs that are ready to be executed. If that queue is full, no more jobs will be added to the queue until a job has been executed. A simple example: You have only one processor (therefore maximum 4 jobs executed at the same time) and a cron job that runs every minute. The job takes six minutes to complete. So after four minutes the queue is full, and no more jobs will be added to the queue. After the fifth minute, the queue is still full, and no more jobs will be added to the queue. After the sixth minute, the first job is removed from the queue, and the next job is added to the queue. Therefore it can happen that jobs are skipped and not executed. The same applies to the SupportsConcurrencyAttribute discussed in: Concurrency Control","title":"Global Concurrency"},{"location":"advanced/global-concurrency/#global-concurrency","text":"NCronJob utilisies a priority queue with a maximum amount of entries. That is, the queue will only hold and execute a maximum amount of jobs at any given time. This is to prevent the system from being overloaded with jobs.","title":"Global Concurrency"},{"location":"advanced/global-concurrency/#the-maxmimum","text":"The global maximum of concurrent jobs is calculated as: var maxDegreeOfParallelism = Environment . ProcessorCount * 4 ; If you have a CPU with 12 Cores (like a M2 Processor), the maximum amount of concurrent jobs will be 48. A CRON job is rescheduled after it has been executed. This means that the queue will always be filled with jobs that are ready to be executed. If that queue is full, no more jobs will be added to the queue until a job has been executed. A simple example: You have only one processor (therefore maximum 4 jobs executed at the same time) and a cron job that runs every minute. The job takes six minutes to complete. So after four minutes the queue is full, and no more jobs will be added to the queue. After the fifth minute, the queue is still full, and no more jobs will be added to the queue. After the sixth minute, the first job is removed from the queue, and the next job is added to the queue. Therefore it can happen that jobs are skipped and not executed. The same applies to the SupportsConcurrencyAttribute discussed in: Concurrency Control","title":"The Maxmimum"},{"location":"advanced/log-level/","text":"Controlling the log-level \u00b6 The NCronJob scheduler can be configured to log at a specific log level. { \"Logging\" : { \"LogLevel\" : { \"Default\" : \"Information\" , \"Microsoft.AspNetCore\" : \"Warning\" , \"NCronJob\" : \"Debug\"","title":"Controlling the log level"},{"location":"advanced/log-level/#controlling-the-log-level","text":"The NCronJob scheduler can be configured to log at a specific log level. { \"Logging\" : { \"LogLevel\" : { \"Default\" : \"Information\" , \"Microsoft.AspNetCore\" : \"Warning\" , \"NCronJob\" : \"Debug\"","title":"Controlling the log-level"},{"location":"features/concurrency-control/","text":"Concurrency Control \u00b6 Concurrency support allows multiple instances of the same job type to run simultaneously, controlled by the SupportsConcurrency attribute. This feature is crucial for efficiently managing jobs that are capable of running in parallel without interference. By default jobs are not executed concurrently if the SupportsConcurrency attribute is not set. How It Works \u00b6 The SupportsConcurrency attribute specifies the maximum degree of parallelism for job instances. This means you can define how many instances of a particular job can run concurrently, optimizing performance and resource utilization based on the nature of the job and the system capabilities. Using the SupportsConcurrency Attribute \u00b6 Here is an example of how to apply this attribute to a job: Example: Concurrency in Jobs \u00b6 [SupportsConcurrency(10)] public class ConcurrentJob : IJob { private readonly ILogger < ConcurrentJob > logger ; public ConcurrentJob ( ILogger < ConcurrentJob > logger ) { this . logger = logger ; } public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} is running.\" ); // Simulate some work by delaying await Task . Delay ( 5000 , token ); logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} has completed.\" ); } } Important Considerations \u00b6 Ensuring Job Idempotency \u00b6 When using concurrency, it\u2019s essential to ensure that each job instance is idempotent. This means that even if the job is executed multiple times concurrently or sequentially, the outcome and side effects should remain consistent, without unintended duplication or conflict. Resource Allocation Caution \u00b6 Jobs that are marked to support concurrency should be designed carefully to avoid contention over shared resources. This includes, but is not limited to, database connections, file handles, or any external systems. In scenarios where shared resources are unavoidable, proper synchronization mechanisms or concurrency control techniques, such as semaphores, mutexes, or transactional control, should be implemented to prevent race conditions and ensure data integrity.","title":"Concurrency control"},{"location":"features/concurrency-control/#concurrency-control","text":"Concurrency support allows multiple instances of the same job type to run simultaneously, controlled by the SupportsConcurrency attribute. This feature is crucial for efficiently managing jobs that are capable of running in parallel without interference. By default jobs are not executed concurrently if the SupportsConcurrency attribute is not set.","title":"Concurrency Control"},{"location":"features/concurrency-control/#how-it-works","text":"The SupportsConcurrency attribute specifies the maximum degree of parallelism for job instances. This means you can define how many instances of a particular job can run concurrently, optimizing performance and resource utilization based on the nature of the job and the system capabilities.","title":"How It Works"},{"location":"features/concurrency-control/#using-the-supportsconcurrency-attribute","text":"Here is an example of how to apply this attribute to a job:","title":"Using the SupportsConcurrency Attribute"},{"location":"features/concurrency-control/#example-concurrency-in-jobs","text":"[SupportsConcurrency(10)] public class ConcurrentJob : IJob { private readonly ILogger < ConcurrentJob > logger ; public ConcurrentJob ( ILogger < ConcurrentJob > logger ) { this . logger = logger ; } public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} is running.\" ); // Simulate some work by delaying await Task . Delay ( 5000 , token ); logger . LogInformation ( $\"ConcurrentJob with Id {context.Id} has completed.\" ); } }","title":"Example: Concurrency in Jobs"},{"location":"features/concurrency-control/#important-considerations","text":"","title":"Important Considerations"},{"location":"features/concurrency-control/#ensuring-job-idempotency","text":"When using concurrency, it\u2019s essential to ensure that each job instance is idempotent. This means that even if the job is executed multiple times concurrently or sequentially, the outcome and side effects should remain consistent, without unintended duplication or conflict.","title":"Ensuring Job Idempotency"},{"location":"features/concurrency-control/#resource-allocation-caution","text":"Jobs that are marked to support concurrency should be designed carefully to avoid contention over shared resources. This includes, but is not limited to, database connections, file handles, or any external systems. In scenarios where shared resources are unavoidable, proper synchronization mechanisms or concurrency control techniques, such as semaphores, mutexes, or transactional control, should be implemented to prevent race conditions and ensure data integrity.","title":"Resource Allocation Caution"},{"location":"features/define-and-schedule-jobs/","text":"Define and schedule jobs \u00b6 Understanding IJob \u00b6 In NCronJob , jobs are defined by implementing the IJob interface. This interface contains a single method, RunAsync , where you define the task\u2019s execution logic. NCronJob registers IJob implementations as scoped services within your application\u2019s dependency injection container. This means that a new scope is created for each job execution, ensuring isolation and allowing for clean dependency management (particularly important when working with frameworks like Entity Framework Core). Defining a Job \u00b6 Follow these steps to create and schedule a job in NCronJob: public class MyCronJob : IJob { private readonly ILogger < MyCronJob > _logger ; public MyCronJob ( ILogger < MyCronJob > logger ) { // MyCronJob lives in the container so you can inject services here _logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { _logger . LogInformation ( \"MyCronJob is executing!\" ); // Add your job logic here (e.g., database updates, sending emails, etc.) return Task . CompletedTask ; } } Registering the Job \u00b6 using NCronJob ; // Inside your service configuration Services . AddNCronJob ( options => { options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ); // Runs every 5 minutes }); }); Chaining Cron Expressions with And \u00b6 Execute the same job on multiple schedules using the And command: Services . AddNCronJob ( options => { options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"0 8 * * *\" ) // Every day at 8:00 AM . And . WithCronExpression ( \"0 20 * * *\" ); // Every day at 8:00 PM }); }); Scheduling Jobs With Time Zones \u00b6 The library offers you the ability to schedule jobs using time zones. Services . AddNCronJob ( options => { var timeZone = TimeZoneInfo . FindSystemTimeZoneById ( \"Pacific Standard Time\" ); options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"0 15 * * *\" , timeZoneInfo : timeZone ); // Every day at 3:00 PM PST }); });","title":"Define and Schedule Jobs"},{"location":"features/define-and-schedule-jobs/#define-and-schedule-jobs","text":"","title":"Define and schedule jobs"},{"location":"features/define-and-schedule-jobs/#understanding-ijob","text":"In NCronJob , jobs are defined by implementing the IJob interface. This interface contains a single method, RunAsync , where you define the task\u2019s execution logic. NCronJob registers IJob implementations as scoped services within your application\u2019s dependency injection container. This means that a new scope is created for each job execution, ensuring isolation and allowing for clean dependency management (particularly important when working with frameworks like Entity Framework Core).","title":"Understanding IJob"},{"location":"features/define-and-schedule-jobs/#defining-a-job","text":"Follow these steps to create and schedule a job in NCronJob: public class MyCronJob : IJob { private readonly ILogger < MyCronJob > _logger ; public MyCronJob ( ILogger < MyCronJob > logger ) { // MyCronJob lives in the container so you can inject services here _logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { _logger . LogInformation ( \"MyCronJob is executing!\" ); // Add your job logic here (e.g., database updates, sending emails, etc.) return Task . CompletedTask ; } }","title":"Defining a Job"},{"location":"features/define-and-schedule-jobs/#registering-the-job","text":"using NCronJob ; // Inside your service configuration Services . AddNCronJob ( options => { options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ); // Runs every 5 minutes }); });","title":"Registering the Job"},{"location":"features/define-and-schedule-jobs/#chaining-cron-expressions-with-and","text":"Execute the same job on multiple schedules using the And command: Services . AddNCronJob ( options => { options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"0 8 * * *\" ) // Every day at 8:00 AM . And . WithCronExpression ( \"0 20 * * *\" ); // Every day at 8:00 PM }); });","title":"Chaining Cron Expressions with And"},{"location":"features/define-and-schedule-jobs/#scheduling-jobs-with-time-zones","text":"The library offers you the ability to schedule jobs using time zones. Services . AddNCronJob ( options => { var timeZone = TimeZoneInfo . FindSystemTimeZoneById ( \"Pacific Standard Time\" ); options . AddJob < MyCronJob >( j => { j . WithCronExpression ( \"0 15 * * *\" , timeZoneInfo : timeZone ); // Every day at 3:00 PM PST }); });","title":"Scheduling Jobs With Time Zones"},{"location":"features/instant-jobs/","text":"Triggering instant jobs \u00b6 NCronJob allows you to trigger jobs instantly. This is useful when you want to run a job immediately without waiting for the next scheduled time. For example you get a API request and want to offload the work to a background job immediately. Instant jobs are like \u201cregular\u201d CRON jobs and inherit from IJob . The only difference is that they are triggered manually. So also CRON jobs can be triggered instantly. public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { ParameterDto dto = ( ParameterDto ) context . Parameter ; // Do something return Task . CompletedTask ; } } As CRON jobs, they have to be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyJob >(); // No need to specify a CRON expression }); There is no need of a CRON expression for instant jobs. Also passing in parameters doesn\u2019t do anything, they will be passed in differently. Let\u2019s have a look at how to trigger an instant job. Imagine we have a Minimal API where we want to send an E-Mail: app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob < MyJob >( parameterDto ); return Results . Ok (); }); The RunInstantJob method takes the job type and the parameters as arguments. Optionally you can pass in a CancellationToken as well. The job will be executed immediately. Starting a job with a delay \u00b6 If you find the need of delaying the execution of an instant job, you can use the RunScheduledJob method with a TimeSpan as a delay. The same as RunInstantJob applies here, the job has to be registered in the AddNCronJob method. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( TimeSpan . FromMinutes ( 5 ), parameterDto ); return Results . Ok (); }); Starting a job at a specific date and time \u00b6 If you want to start a job at a specific date and time, you can use the RunScheduledJob method with a DateTimeOffset as a parameter. The same as before: The job has to be registered. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( new DateTimeOffset ( 2024 , 1 , 1 , 0 , 0 , 0 , TimeSpan . FromHours ( 2 )), parameterDto ); return Results . Ok (); }); Priority \u00b6 Instant jobs are executed with a higher priority than CRON jobs. This means that if you have a CRON job that is scheduled to run at the same time as an instant job, the instant job will be executed first (and if both of them are competing for the same resources, the instant job will be executed). Minimal API \u00b6 Running instant jobs can also be done with the minimal API ( Minimal API ), which allows to create an anonymous lambda, that can also contain dependencies. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob ( async ( HttpClient httpClient ) => { await httpClient . PostAsync ( \"https://api.example.com/send-email\" , new StringContent ( JsonSerializer . Serialize ( parameterDto ))); }); return TypedResults . Ok (); });","title":"Triggering instant jobs"},{"location":"features/instant-jobs/#triggering-instant-jobs","text":"NCronJob allows you to trigger jobs instantly. This is useful when you want to run a job immediately without waiting for the next scheduled time. For example you get a API request and want to offload the work to a background job immediately. Instant jobs are like \u201cregular\u201d CRON jobs and inherit from IJob . The only difference is that they are triggered manually. So also CRON jobs can be triggered instantly. public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { ParameterDto dto = ( ParameterDto ) context . Parameter ; // Do something return Task . CompletedTask ; } } As CRON jobs, they have to be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyJob >(); // No need to specify a CRON expression }); There is no need of a CRON expression for instant jobs. Also passing in parameters doesn\u2019t do anything, they will be passed in differently. Let\u2019s have a look at how to trigger an instant job. Imagine we have a Minimal API where we want to send an E-Mail: app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob < MyJob >( parameterDto ); return Results . Ok (); }); The RunInstantJob method takes the job type and the parameters as arguments. Optionally you can pass in a CancellationToken as well. The job will be executed immediately.","title":"Triggering instant jobs"},{"location":"features/instant-jobs/#starting-a-job-with-a-delay","text":"If you find the need of delaying the execution of an instant job, you can use the RunScheduledJob method with a TimeSpan as a delay. The same as RunInstantJob applies here, the job has to be registered in the AddNCronJob method. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( TimeSpan . FromMinutes ( 5 ), parameterDto ); return Results . Ok (); });","title":"Starting a job with a delay"},{"location":"features/instant-jobs/#starting-a-job-at-a-specific-date-and-time","text":"If you want to start a job at a specific date and time, you can use the RunScheduledJob method with a DateTimeOffset as a parameter. The same as before: The job has to be registered. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( new DateTimeOffset ( 2024 , 1 , 1 , 0 , 0 , 0 , TimeSpan . FromHours ( 2 )), parameterDto ); return Results . Ok (); });","title":"Starting a job at a specific date and time"},{"location":"features/instant-jobs/#priority","text":"Instant jobs are executed with a higher priority than CRON jobs. This means that if you have a CRON job that is scheduled to run at the same time as an instant job, the instant job will be executed first (and if both of them are competing for the same resources, the instant job will be executed).","title":"Priority"},{"location":"features/instant-jobs/#minimal-api","text":"Running instant jobs can also be done with the minimal API ( Minimal API ), which allows to create an anonymous lambda, that can also contain dependencies. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob ( async ( HttpClient httpClient ) => { await httpClient . PostAsync ( \"https://api.example.com/send-email\" , new StringContent ( JsonSerializer . Serialize ( parameterDto ))); }); return TypedResults . Ok (); });","title":"Minimal API"},{"location":"features/minimal-api/","text":"Minimal API \u00b6 The minimal job API offers another way of defining a cron job. It favors simplicity over feature richness. A job can be defined as such: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); This call will register all the necessary services and the job in question. The method can be called multiple times to register multiple jobs: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); builder . Services . AddNCronJob (() => { }, \"1 * * * *\" ); The minimal job API does support resolving services from the DI container. The following example demonstrates how to resolve a logger and a TimeProvider : builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); Also the JobExecutionContext and CancellationToken can be resolved from the DI container: builder . Services . AddNCronJob (( JobExecutionContext context , CancellationToken token ) => { }, \"*/5 * * * * *\" ); The token can be used to get notified when the job should be cancelled (for example if the whole application gets shut down). Of course functions can be asynchrnous in nature as well: builder . Services . AddNCronJob ( async ( HttpClient httpClient ) => { using var response = await httpClient . GetAsync ( \"https://github.com/NCronJob-Dev/NCronJob\" ); var content = await response . Content . ReadAsStringAsync (); }, \"*/5 * * * * *\" ); There are certain restrictions that can\u2019t be enforced at compile time (due to a missing interface) which will lead to a runtime exception: The job has to return void or Task , otherwise an InvalidOperationException will be thrown. Retry-Support \u00b6 The minimal job API does support the Retry model as well. The minimal job API leverages the fact that lambdas also can have attributes: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] () => { }, \"0 * * * *\" ); To know in which attempt the job currently is, the JobExecutionContext can be used: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] ( JobExecutionContext context ) => { if ( context . Attempts == 1 ) { // First attempt } }, \"0 * * * *\" ); Time Zone \u00b6 The time zone can be controlled as well and defaults to UTC if not specified: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" , TimeZoneInfo . Local ); Concurrency-Support \u00b6 In the same way, the concurrency level can be controlled (see Concurrency ): builder . Services . AddNCronJob ([ SupportsConcurrency ( 2 )] () => { }, \"0 * * * *\" ); Now, the job can only be executed by two instances at the same time. Restrictions \u00b6 The minimal API has some restrictions over the \u201cfull approach\u201d: Some errors can only be detected at runtime (for example if the job does not return void or Task ). Minimal API for instant Jobs \u00b6 The minimal API also supports instant jobs, for this check out the Instant Jobs documentation. Minimal API for dependent jobs \u00b6 The minimal API also supports dependent jobs, for this check out the Dependent Jobs documentation.","title":"Minimal API"},{"location":"features/minimal-api/#minimal-api","text":"The minimal job API offers another way of defining a cron job. It favors simplicity over feature richness. A job can be defined as such: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); This call will register all the necessary services and the job in question. The method can be called multiple times to register multiple jobs: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" ); builder . Services . AddNCronJob (() => { }, \"1 * * * *\" ); The minimal job API does support resolving services from the DI container. The following example demonstrates how to resolve a logger and a TimeProvider : builder . Services . AddNCronJob (( ILogger < Program > logger , TimeProvider timeProvider ) => { logger . LogInformation ( \"Hello World - The current date and time is {Time}\" , timeProvider . GetLocalNow ()); }, \"*/5 * * * * *\" ); Also the JobExecutionContext and CancellationToken can be resolved from the DI container: builder . Services . AddNCronJob (( JobExecutionContext context , CancellationToken token ) => { }, \"*/5 * * * * *\" ); The token can be used to get notified when the job should be cancelled (for example if the whole application gets shut down). Of course functions can be asynchrnous in nature as well: builder . Services . AddNCronJob ( async ( HttpClient httpClient ) => { using var response = await httpClient . GetAsync ( \"https://github.com/NCronJob-Dev/NCronJob\" ); var content = await response . Content . ReadAsStringAsync (); }, \"*/5 * * * * *\" ); There are certain restrictions that can\u2019t be enforced at compile time (due to a missing interface) which will lead to a runtime exception: The job has to return void or Task , otherwise an InvalidOperationException will be thrown.","title":"Minimal API"},{"location":"features/minimal-api/#retry-support","text":"The minimal job API does support the Retry model as well. The minimal job API leverages the fact that lambdas also can have attributes: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] () => { }, \"0 * * * *\" ); To know in which attempt the job currently is, the JobExecutionContext can be used: builder . Services . AddNCronJob ([ RetryPolicy ( retryCount : 3 )] ( JobExecutionContext context ) => { if ( context . Attempts == 1 ) { // First attempt } }, \"0 * * * *\" );","title":"Retry-Support"},{"location":"features/minimal-api/#time-zone","text":"The time zone can be controlled as well and defaults to UTC if not specified: builder . Services . AddNCronJob (() => { }, \"0 * * * *\" , TimeZoneInfo . Local );","title":"Time Zone"},{"location":"features/minimal-api/#concurrency-support","text":"In the same way, the concurrency level can be controlled (see Concurrency ): builder . Services . AddNCronJob ([ SupportsConcurrency ( 2 )] () => { }, \"0 * * * *\" ); Now, the job can only be executed by two instances at the same time.","title":"Concurrency-Support"},{"location":"features/minimal-api/#restrictions","text":"The minimal API has some restrictions over the \u201cfull approach\u201d: Some errors can only be detected at runtime (for example if the job does not return void or Task ).","title":"Restrictions"},{"location":"features/minimal-api/#minimal-api-for-instant-jobs","text":"The minimal API also supports instant jobs, for this check out the Instant Jobs documentation.","title":"Minimal API for instant Jobs"},{"location":"features/minimal-api/#minimal-api-for-dependent-jobs","text":"The minimal API also supports dependent jobs, for this check out the Dependent Jobs documentation.","title":"Minimal API for dependent jobs"},{"location":"features/model-dependencies/","text":"Model Dependencies \u00b6 This chapter explains how to define jobs that should automatically run based on the completion of other jobs. This feature is useful when you have a series of tasks that must be executed in a specific order allowing to build a pipeline of jobs. Modelling Dependencies with ExecuteWhen \u00b6 In NCronJob , you can define job dependencies using the ExecuteWhen method. This method allows you to specify that a job should run only after another job has completed successfully or faulted. Services . AddNCronJob ( options => { options . AddJob < JobB >(). ExecuteWhen ( success : s => s . RunJob < SuccessJob >(), faulted : f => f . RunJob < FaultedJob >()); }); Both success and faulted are optional so that you can define only one of them if needed. RunJob can be chained to allow multiple jobs to run after the completion of the main job. This allows very complex job dependencies to be defined in a simple and readable way. Passing parameters to dependent jobs \u00b6 The RunJob method allows optional parameters to be passed to the dependent job. Services . AddNCronJob ( options => { options . AddJob < JobB >(). ExecuteWhen ( success : s => s . RunJob < SuccessJob >( \"Foo\" )); }); Accessing the state of the parent job \u00b6 The JobExecutionContext object passed to the dependent job contains the output of the parent job. This allows access to the state of the parent job. This can be helpful if information should flow from parent to the child job. public class JobA : IJob { public Task ExecuteAsync ( JobExecutionContext context ) { context . Output = \"Hello World\" ; return Task . CompletedTask ; } } public class JobB : IJob { public Task ExecuteAsync ( JobExecutionContext context ) { var parentOutput = context . ParentOutput ; // \"Hello World\" return Task . CompletedTask ; } } // Register the dependency so that JobB runs after JobA automatically Services . AddNCronJob ( options => { options . AddJob < JobA >(). ExecuteWhen ( success : s => s . RunJob < JobB >()); }); Order of execution between INotificationJobHandler and dependent jobs \u00b6 If a job has a dependency on another job, the dependent job will run after the INotificationJobHandler has been executed and awaited. Tracing requests of dependencies via CorrelationId \u00b6 Every JobExecutionContext has a CorrelationId property that can be used to trace the execution of dependent jobs. This property is automatically set to the CorrelationId of the parent job and stays the same for all dependent jobs down the chain. Cancelling dependent jobs \u00b6 To actively cancel dependent jobs, the JobExecutionContext object passed offers a SkipChildren method. This method can be called to prevent dependent jobs from running. public class JobA : IJob { public Task ExecuteAsync ( JobExecutionContext context ) { context . SkipChildren (); return Task . CompletedTask ; } } public class JobB : IJob { public Task ExecuteAsync ( JobExecutionContext context ) { // This job will not run return Task . CompletedTask ; } } builder . Services . AddNCronJob ( options => { options . AddJob < JobA >(). ExecuteWhen ( success : s => s . RunJob < JobB >()); }); Minimal API \u00b6 The ExecuteWhen method can also be used in a Minimal API to define job dependencies: builder . Services . AddNCronJob ( options => { options . AddJob < ImportDataJob >(). ExecuteWhen ( success : s => s . RunJob ( async ( ITransfomerService transformerService ) => await transformerService . TransformDataAsync ()), faulted : f => f . RunJob ( async ( INotificationService notificationService ) => await notificationService . SendNotificationAsync ())); }); Getting the parent job\u2019s output in a Minimal API \u00b6 If you pass in a JobExecutionContext to the dependent job, you can access the parent job\u2019s output: builder . Services . AddNCronJob ( options => { options . AddJob < ImportDataJob >(). ExecuteWhen ( success : s => s . RunJob ( async ( JobExecutionContext context , ITransfomerService transformerService ) => { var parentOutput = ( MyDataModel ) context . ParentOutput ; await transformerService . TransformDataAsync ( parentOutput ); })); }); Defining dependencies for minimal Jobs \u00b6 To define that a job should be executed afterward, you can use the AddJob overload like this: builder . Services . AddNCronJob ( options => { options . AddJob ( async ( IMyService myService ) => await myService . Run ()) . ExecuteWhen ( success : b => b . RunJob (() => Console . Write ( \"Run when successful\" ))); });","title":"Model dependencies"},{"location":"features/model-dependencies/#model-dependencies","text":"This chapter explains how to define jobs that should automatically run based on the completion of other jobs. This feature is useful when you have a series of tasks that must be executed in a specific order allowing to build a pipeline of jobs.","title":"Model Dependencies"},{"location":"features/model-dependencies/#modelling-dependencies-with-executewhen","text":"In NCronJob , you can define job dependencies using the ExecuteWhen method. This method allows you to specify that a job should run only after another job has completed successfully or faulted. Services . AddNCronJob ( options => { options . AddJob < JobB >(). ExecuteWhen ( success : s => s . RunJob < SuccessJob >(), faulted : f => f . RunJob < FaultedJob >()); }); Both success and faulted are optional so that you can define only one of them if needed. RunJob can be chained to allow multiple jobs to run after the completion of the main job. This allows very complex job dependencies to be defined in a simple and readable way.","title":"Modelling Dependencies with ExecuteWhen"},{"location":"features/model-dependencies/#passing-parameters-to-dependent-jobs","text":"The RunJob method allows optional parameters to be passed to the dependent job. Services . AddNCronJob ( options => { options . AddJob < JobB >(). ExecuteWhen ( success : s => s . RunJob < SuccessJob >( \"Foo\" )); });","title":"Passing parameters to dependent jobs"},{"location":"features/model-dependencies/#accessing-the-state-of-the-parent-job","text":"The JobExecutionContext object passed to the dependent job contains the output of the parent job. This allows access to the state of the parent job. This can be helpful if information should flow from parent to the child job. public class JobA : IJob { public Task ExecuteAsync ( JobExecutionContext context ) { context . Output = \"Hello World\" ; return Task . CompletedTask ; } } public class JobB : IJob { public Task ExecuteAsync ( JobExecutionContext context ) { var parentOutput = context . ParentOutput ; // \"Hello World\" return Task . CompletedTask ; } } // Register the dependency so that JobB runs after JobA automatically Services . AddNCronJob ( options => { options . AddJob < JobA >(). ExecuteWhen ( success : s => s . RunJob < JobB >()); });","title":"Accessing the state of the parent job"},{"location":"features/model-dependencies/#order-of-execution-between-inotificationjobhandler-and-dependent-jobs","text":"If a job has a dependency on another job, the dependent job will run after the INotificationJobHandler has been executed and awaited.","title":"Order of execution between INotificationJobHandler and dependent jobs"},{"location":"features/model-dependencies/#tracing-requests-of-dependencies-via-correlationid","text":"Every JobExecutionContext has a CorrelationId property that can be used to trace the execution of dependent jobs. This property is automatically set to the CorrelationId of the parent job and stays the same for all dependent jobs down the chain.","title":"Tracing requests of dependencies via CorrelationId"},{"location":"features/model-dependencies/#cancelling-dependent-jobs","text":"To actively cancel dependent jobs, the JobExecutionContext object passed offers a SkipChildren method. This method can be called to prevent dependent jobs from running. public class JobA : IJob { public Task ExecuteAsync ( JobExecutionContext context ) { context . SkipChildren (); return Task . CompletedTask ; } } public class JobB : IJob { public Task ExecuteAsync ( JobExecutionContext context ) { // This job will not run return Task . CompletedTask ; } } builder . Services . AddNCronJob ( options => { options . AddJob < JobA >(). ExecuteWhen ( success : s => s . RunJob < JobB >()); });","title":"Cancelling dependent jobs"},{"location":"features/model-dependencies/#minimal-api","text":"The ExecuteWhen method can also be used in a Minimal API to define job dependencies: builder . Services . AddNCronJob ( options => { options . AddJob < ImportDataJob >(). ExecuteWhen ( success : s => s . RunJob ( async ( ITransfomerService transformerService ) => await transformerService . TransformDataAsync ()), faulted : f => f . RunJob ( async ( INotificationService notificationService ) => await notificationService . SendNotificationAsync ())); });","title":"Minimal API"},{"location":"features/model-dependencies/#getting-the-parent-jobs-output-in-a-minimal-api","text":"If you pass in a JobExecutionContext to the dependent job, you can access the parent job\u2019s output: builder . Services . AddNCronJob ( options => { options . AddJob < ImportDataJob >(). ExecuteWhen ( success : s => s . RunJob ( async ( JobExecutionContext context , ITransfomerService transformerService ) => { var parentOutput = ( MyDataModel ) context . ParentOutput ; await transformerService . TransformDataAsync ( parentOutput ); })); });","title":"Getting the parent job&rsquo;s output in a Minimal API"},{"location":"features/model-dependencies/#defining-dependencies-for-minimal-jobs","text":"To define that a job should be executed afterward, you can use the AddJob overload like this: builder . Services . AddNCronJob ( options => { options . AddJob ( async ( IMyService myService ) => await myService . Run ()) . ExecuteWhen ( success : b => b . RunJob (() => Console . Write ( \"Run when successful\" ))); });","title":"Defining dependencies for minimal Jobs"},{"location":"features/multiple-cron-expressions/","text":"Registering multiple CRON expressions \u00b6 The flient builder allows you to register multiple CRON expressions for a single job. This is useful when you want to run a job at different times of the day. For example: Services . AddNCronJob ( options => { // Register a job that runs at midnight and midday options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"0 0 * * *\" ) // Run at midnight . And . WithCronExpression ( \"0 12 * * *\" ); // Run at midday }); }); The And method is used to chain multiple CRON expressions together. You can chain as many expressions as you like. If a given job has the same CRON expression registered multiple times, it will be executed multiple times as well. Services . AddNCronJob ( options => { // Register a job that runs every 5 minutes options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ) // Run every 5 minutes . And . WithCronExpression ( \"*/5 * * * *\" ); // Run every 5 minutes }); }); Two instances of the ExampleJob class will be created and executed every 5 minutes.","title":"Registering multiple CRON expressions"},{"location":"features/multiple-cron-expressions/#registering-multiple-cron-expressions","text":"The flient builder allows you to register multiple CRON expressions for a single job. This is useful when you want to run a job at different times of the day. For example: Services . AddNCronJob ( options => { // Register a job that runs at midnight and midday options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"0 0 * * *\" ) // Run at midnight . And . WithCronExpression ( \"0 12 * * *\" ); // Run at midday }); }); The And method is used to chain multiple CRON expressions together. You can chain as many expressions as you like. If a given job has the same CRON expression registered multiple times, it will be executed multiple times as well. Services . AddNCronJob ( options => { // Register a job that runs every 5 minutes options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ) // Run every 5 minutes . And . WithCronExpression ( \"*/5 * * * *\" ); // Run every 5 minutes }); }); Two instances of the ExampleJob class will be created and executed every 5 minutes.","title":"Registering multiple CRON expressions"},{"location":"features/notifications/","text":"Notificatins \u00b6 NCronJob provides a way to get notified when a job is done. For this, implement a IJobNotificationHandler<TJob> and register it in your DI container. builder . Services . AddNCronJob ( options => options . AddCronJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }) . AddNotificationHandler < MyJobNotificationHandler >()); This allows to run logic after a job is done. The JobExecutionContext and the Exception (if there was one) are passed to the Handle method. public class MyJobNotificationHandler : IJobNotificationHandler < MyJob > { private readonly ILogger < MyJobNotificationHandler > logger ; public MyJobNotificationHandler ( ILogger < MyJobNotificationHandler > logger ) { this . logger = logger ; } public Task HandleAsync ( JobExecutionContext context , Exception ? exception , CancellationToken token ) { if ( exception is not null ) { logger . LogError ( exception , \"Job failed\" ); } else { logger . LogInformation ( \"Job was successful\" ); logger . LogInformation ( \"Output: {Output}\" , context . Output ); } return Task . CompletedTask ; } }","title":"Notifications"},{"location":"features/notifications/#notificatins","text":"NCronJob provides a way to get notified when a job is done. For this, implement a IJobNotificationHandler<TJob> and register it in your DI container. builder . Services . AddNCronJob ( options => options . AddCronJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }) . AddNotificationHandler < MyJobNotificationHandler >()); This allows to run logic after a job is done. The JobExecutionContext and the Exception (if there was one) are passed to the Handle method. public class MyJobNotificationHandler : IJobNotificationHandler < MyJob > { private readonly ILogger < MyJobNotificationHandler > logger ; public MyJobNotificationHandler ( ILogger < MyJobNotificationHandler > logger ) { this . logger = logger ; } public Task HandleAsync ( JobExecutionContext context , Exception ? exception , CancellationToken token ) { if ( exception is not null ) { logger . LogError ( exception , \"Job failed\" ); } else { logger . LogInformation ( \"Job was successful\" ); logger . LogInformation ( \"Output: {Output}\" , context . Output ); } return Task . CompletedTask ; } }","title":"Notificatins"},{"location":"features/parameters/","text":"Passing parameters to a job \u00b6 Often times a job needs some kind of configuration or parameter to run. Imagine you have a job that generates a report and can run daily, weekly or monthly. You could create three different jobs for each frequency, but that would be a lot of duplicated code. Instead, you can pass in parameters to the job. Services . AddNCronJob ( options => { options . AddJob < ReportJob >( j => { // Runs every day at midnight and passes in the string \"daily\" j . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"daily\" ) . And . WithCronExpression ( \"0 0 * * 0\" ). WithParameter ( \"weekly\" ) . And . WithCronExpression ( \"0 0 1 * *\" ). WithParameter ( \"monthly\" ); }); }); In the ReportJob you can now access the parameter via the JobExecutionContext : public class ReportJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var parameter = context . Parameter ; // Do something with the parameter switch ( parameter ) { case \"daily\" : // Generate daily report break ; case \"weekly\" : // Generate weekly report break ; case \"monthly\" : // Generate monthly report break ; } return Task . CompletedTask ; } } Parameters are not immutable \u00b6 Passed in parameters are not immutable by default or cloned through out the job execution. This means that if you change the parameter in the job, it will also change in the next execution. If you need to keep the parameter unchanged, you should clone it in the job. public class MyParameter { public int Counter { get ; set ; } } Services . AddNCronJob ( b => { b . AddJob < MyJob >( p => p . WithCronExpression (...)); }); public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var myParam = ( MyParameter ) context . Parameter ; myParam . Counter ++; // This will be incremented with each job run } } If MyJob runs twice already and is invoked a third time, myParam.Counter will be 2 when the function gets invoked.","title":"Passing Parameters"},{"location":"features/parameters/#passing-parameters-to-a-job","text":"Often times a job needs some kind of configuration or parameter to run. Imagine you have a job that generates a report and can run daily, weekly or monthly. You could create three different jobs for each frequency, but that would be a lot of duplicated code. Instead, you can pass in parameters to the job. Services . AddNCronJob ( options => { options . AddJob < ReportJob >( j => { // Runs every day at midnight and passes in the string \"daily\" j . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"daily\" ) . And . WithCronExpression ( \"0 0 * * 0\" ). WithParameter ( \"weekly\" ) . And . WithCronExpression ( \"0 0 1 * *\" ). WithParameter ( \"monthly\" ); }); }); In the ReportJob you can now access the parameter via the JobExecutionContext : public class ReportJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var parameter = context . Parameter ; // Do something with the parameter switch ( parameter ) { case \"daily\" : // Generate daily report break ; case \"weekly\" : // Generate weekly report break ; case \"monthly\" : // Generate monthly report break ; } return Task . CompletedTask ; } }","title":"Passing parameters to a job"},{"location":"features/parameters/#parameters-are-not-immutable","text":"Passed in parameters are not immutable by default or cloned through out the job execution. This means that if you change the parameter in the job, it will also change in the next execution. If you need to keep the parameter unchanged, you should clone it in the job. public class MyParameter { public int Counter { get ; set ; } } Services . AddNCronJob ( b => { b . AddJob < MyJob >( p => p . WithCronExpression (...)); }); public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var myParam = ( MyParameter ) context . Parameter ; myParam . Counter ++; // This will be incremented with each job run } } If MyJob runs twice already and is invoked a third time, myParam.Counter will be 2 when the function gets invoked.","title":"Parameters are not immutable"},{"location":"features/retry-support/","text":"Retry Support \u00b6 The new Retry support provides a robust mechanism for handling transient failures by retrying failed operations. This feature is implemented using the RetryPolicy attribute that can be applied to any class implementing the IJob interface. How It Works \u00b6 The RetryPolicy attribute allows you to specify the number of retry attempts and the strategy for handling retries. There are two built-in retry strategies: - ExponentialBackoff: Increases the delay between retry attempts exponentially. - FixedInterval: Keeps the delay between retry attempts consistent. Using Retry Policies \u00b6 Here are examples of how to use the built-in retry policies: Example 1: Basic Retry Policy, defaults to Exponential Backoff \u00b6 [RetryPolicy(retryCount: 4)] public class RetryJob ( ILogger < RetryJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"RetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in RetryJob.\" ); } logger . LogInformation ( $\"RetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } Example 2: Fixed Interval \u00b6 [RetryPolicy(4, PolicyType.FixedInterval)] public class FixedIntervalRetryJob ( ILogger < FixedIntervalRetryJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"FixedIntervalRetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } Advanced: Custom Retry Policies \u00b6 You can also create custom retry policies by implementing the IPolicyCreator interface. This allows you to define complex retry logic tailored to your specific needs. [RetryPolicy<MyCustomPolicyCreator>(retryCount:4, delayFactor:1)] public class CustomPolicyJob ( ILogger < CustomPolicyJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"CustomPolicyJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } public class MyCustomPolicyCreator : IPolicyCreator { public IAsyncPolicy CreatePolicy ( int maxRetryAttempts = 3 , double delayFactor = 2 ) { return Policy . Handle < Exception >() . WaitAndRetryAsync ( maxRetryAttempts , retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( delayFactor , retryAttempt ))); } }","title":"Retry support"},{"location":"features/retry-support/#retry-support","text":"The new Retry support provides a robust mechanism for handling transient failures by retrying failed operations. This feature is implemented using the RetryPolicy attribute that can be applied to any class implementing the IJob interface.","title":"Retry Support"},{"location":"features/retry-support/#how-it-works","text":"The RetryPolicy attribute allows you to specify the number of retry attempts and the strategy for handling retries. There are two built-in retry strategies: - ExponentialBackoff: Increases the delay between retry attempts exponentially. - FixedInterval: Keeps the delay between retry attempts consistent.","title":"How It Works"},{"location":"features/retry-support/#using-retry-policies","text":"Here are examples of how to use the built-in retry policies:","title":"Using Retry Policies"},{"location":"features/retry-support/#example-1-basic-retry-policy-defaults-to-exponential-backoff","text":"[RetryPolicy(retryCount: 4)] public class RetryJob ( ILogger < RetryJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"RetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in RetryJob.\" ); } logger . LogInformation ( $\"RetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } }","title":"Example 1: Basic Retry Policy, defaults to Exponential Backoff"},{"location":"features/retry-support/#example-2-fixed-interval","text":"[RetryPolicy(4, PolicyType.FixedInterval)] public class FixedIntervalRetryJob ( ILogger < FixedIntervalRetryJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"FixedIntervalRetryJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } }","title":"Example 2: Fixed Interval"},{"location":"features/retry-support/#advanced-custom-retry-policies","text":"You can also create custom retry policies by implementing the IPolicyCreator interface. This allows you to define complex retry logic tailored to your specific needs. [RetryPolicy<MyCustomPolicyCreator>(retryCount:4, delayFactor:1)] public class CustomPolicyJob ( ILogger < CustomPolicyJob > logger ) : IJob { public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var attemptCount = context . Attempts ; if ( attemptCount <= 3 ) { logger . LogWarning ( \"FixedIntervalRetryJob simulating failure.\" ); throw new InvalidOperationException ( \"Simulated operation failure in FixedIntervalRetryJob.\" ); } logger . LogInformation ( $\"CustomPolicyJob with Id {context.Id} was attempted {attemptCount} times.\" ); await Task . CompletedTask ; } } public class MyCustomPolicyCreator : IPolicyCreator { public IAsyncPolicy CreatePolicy ( int maxRetryAttempts = 3 , double delayFactor = 2 ) { return Policy . Handle < Exception >() . WaitAndRetryAsync ( maxRetryAttempts , retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( delayFactor , retryAttempt ))); } }","title":"Advanced: Custom Retry Policies"},{"location":"features/startup-jobs/","text":"Running Startup Jobs \u00b6 NCronJob allows you to configure jobs to run at application startup. This is useful for tasks that need to be executed immediately when the application starts, such as initial data loading, cleanup tasks, or other setup procedures. Startup jobs are defined like regular CRON jobs and inherit from IJob . The only difference is that they are configured to run at startup. All startup jobs must be completed prior to the start of any other CRON (or instant) jobs. public class MyStartupJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { // Perform startup task return Task . CompletedTask ; } } As with CRON jobs, they must be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyStartupJob >() . RunAtStartup (); // Configure the job to run at startup }); The RunAtStartup method ensures that the job is executed as soon as the application starts. This method is useful for scenarios where certain tasks need to be performed immediately upon application launch. Example Use Case \u00b6 Consider an application that needs to load initial data from a database or perform some cleanup tasks whenever it starts. You can define and configure a startup job to handle this: Job Definition \u00b6 public class InitialDataLoader : IJob { private readonly IDataService _dataService ; public InitialDataLoader ( IDataService dataService ) { _dataService = dataService ; } public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { await _dataService . LoadInitialDataAsync (); } } Registering the Job \u00b6 In your Program.cs or Startup.cs file, register the job and configure it to run at startup: builder . Services . AddNCronJob ( options => { options . AddJob < InitialDataLoader >() . RunAtStartup (); }); This setup ensures that the InitialDataLoader job will be executed as soon as the application starts, loading the necessary initial data. Summary \u00b6 Startup jobs are a powerful feature of NCronJob that enable you to execute critical tasks immediately upon application startup. By using the RunAtStartup method, you can ensure that your application performs necessary setup procedures, data loading, or cleanup tasks right at the beginning of its lifecycle. This feature is particularly useful for applications that require certain operations to be completed before they are fully functional. By configuring startup jobs, you can streamline your application\u2019s initialization process and improve its overall reliability and performance.","title":"Startup Jobs"},{"location":"features/startup-jobs/#running-startup-jobs","text":"NCronJob allows you to configure jobs to run at application startup. This is useful for tasks that need to be executed immediately when the application starts, such as initial data loading, cleanup tasks, or other setup procedures. Startup jobs are defined like regular CRON jobs and inherit from IJob . The only difference is that they are configured to run at startup. All startup jobs must be completed prior to the start of any other CRON (or instant) jobs. public class MyStartupJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { // Perform startup task return Task . CompletedTask ; } } As with CRON jobs, they must be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyStartupJob >() . RunAtStartup (); // Configure the job to run at startup }); The RunAtStartup method ensures that the job is executed as soon as the application starts. This method is useful for scenarios where certain tasks need to be performed immediately upon application launch.","title":"Running Startup Jobs"},{"location":"features/startup-jobs/#example-use-case","text":"Consider an application that needs to load initial data from a database or perform some cleanup tasks whenever it starts. You can define and configure a startup job to handle this:","title":"Example Use Case"},{"location":"features/startup-jobs/#job-definition","text":"public class InitialDataLoader : IJob { private readonly IDataService _dataService ; public InitialDataLoader ( IDataService dataService ) { _dataService = dataService ; } public async Task RunAsync ( JobExecutionContext context , CancellationToken token ) { await _dataService . LoadInitialDataAsync (); } }","title":"Job Definition"},{"location":"features/startup-jobs/#registering-the-job","text":"In your Program.cs or Startup.cs file, register the job and configure it to run at startup: builder . Services . AddNCronJob ( options => { options . AddJob < InitialDataLoader >() . RunAtStartup (); }); This setup ensures that the InitialDataLoader job will be executed as soon as the application starts, loading the necessary initial data.","title":"Registering the Job"},{"location":"features/startup-jobs/#summary","text":"Startup jobs are a powerful feature of NCronJob that enable you to execute critical tasks immediately upon application startup. By using the RunAtStartup method, you can ensure that your application performs necessary setup procedures, data loading, or cleanup tasks right at the beginning of its lifecycle. This feature is particularly useful for applications that require certain operations to be completed before they are fully functional. By configuring startup jobs, you can streamline your application\u2019s initialization process and improve its overall reliability and performance.","title":"Summary"},{"location":"migration/v2/","text":"v2 Migration Guide \u00b6 This document will describe the changes made in v2 of NCronJob and how to migrate from v1 . Version 2 of NCronJob brings some breaking changes to mae a better API. CronExpression moved towards builder \u00b6 In v1 one would define as such: services . AddNCronJob (); services . AddCronJob < PrintHelloWorld >( options => { options . CronExpression = \"* * * * *\" ; options . Parameter = \"Hello World\" ; }); With v2 the CronExpression is moved towards the builder pattern and AddCronJob is merged into AddNCronJob : Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }); }); This allows to easily define multiple jobs without adding much boilerplate code. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( p => p . WithCronExpression ( \"0 * * * *\" ). WithParameter ( \"Foo\" ) . And . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"Bar\" )); });","title":"v2 Migration Guide"},{"location":"migration/v2/#v2-migration-guide","text":"This document will describe the changes made in v2 of NCronJob and how to migrate from v1 . Version 2 of NCronJob brings some breaking changes to mae a better API.","title":"v2 Migration Guide"},{"location":"migration/v2/#cronexpression-moved-towards-builder","text":"In v1 one would define as such: services . AddNCronJob (); services . AddCronJob < PrintHelloWorld >( options => { options . CronExpression = \"* * * * *\" ; options . Parameter = \"Hello World\" ; }); With v2 the CronExpression is moved towards the builder pattern and AddCronJob is merged into AddNCronJob : Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }); }); This allows to easily define multiple jobs without adding much boilerplate code. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( p => p . WithCronExpression ( \"0 * * * *\" ). WithParameter ( \"Foo\" ) . And . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"Bar\" )); });","title":"CronExpression moved towards builder"}]}