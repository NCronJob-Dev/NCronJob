{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NCronJob \u00b6 A Job Scheduler sitting on top of IHostedService in dotnet. Often times one finds themself between the simplicity of the BackgroundService / IHostedService and the complexity of a full-blown Hangfire or Quartz scheduler. This library aims to fill that gap by providing a simple and easy to use job scheduler that can be used in any dotnet application and feels \u201cnative\u201d. So no need for setting up a database, just schedule your stuff right away! The library gives you two ways of scheduling jobs: Instant jobs - just run a job right away (or with a small delay; or with a given date and time) Cron jobs - schedule a job using a cron expression","title":"NCronJob"},{"location":"#ncronjob","text":"A Job Scheduler sitting on top of IHostedService in dotnet. Often times one finds themself between the simplicity of the BackgroundService / IHostedService and the complexity of a full-blown Hangfire or Quartz scheduler. This library aims to fill that gap by providing a simple and easy to use job scheduler that can be used in any dotnet application and feels \u201cnative\u201d. So no need for setting up a database, just schedule your stuff right away! The library gives you two ways of scheduling jobs: Instant jobs - just run a job right away (or with a small delay; or with a given date and time) Cron jobs - schedule a job using a cron expression","title":"NCronJob"},{"location":"getting-started/","text":"Getting Started \u00b6 Using NCronJob is simple and easy. Just follow the steps below to get started. 1. Install the package \u00b6 Install the latest stable version of the package via NuGet: dotnet add package LinkDotNet.NCronJob Alternatively add the package reference to your .csproj file: <PackageReference Include= \"LinkDotNet.NCronJob\" Version= \"2.1.4\" /> 2. Create a job \u00b6 NCronJob offers a single way of defining jobs: by implementing the IJob interface with a single RunAsync method: public class PrintHelloWorld : IJob { private readonly ILogger < PrintHelloWorld > logger ; public PrintHelloWorld ( ILogger < PrintHelloWorld > logger ) { this . logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( \"Hello World\" ); logger . LogInformation ( \"Parameter: {Parameter}\" , context . Parameter ); return Task . CompletedTask ; } } 3. Register the service and the job \u00b6 The NCronJob library provides one easy entry point for all its magic, the AddNCronJob extension method on top of the IServiceCollection interface. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); })); }); Now your PrintHelloWorld job will run every minute and log \u201cHello World\u201d to the console. And that is all!","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Using NCronJob is simple and easy. Just follow the steps below to get started.","title":"Getting Started"},{"location":"getting-started/#1-install-the-package","text":"Install the latest stable version of the package via NuGet: dotnet add package LinkDotNet.NCronJob Alternatively add the package reference to your .csproj file: <PackageReference Include= \"LinkDotNet.NCronJob\" Version= \"2.1.4\" />","title":"1. Install the package"},{"location":"getting-started/#2-create-a-job","text":"NCronJob offers a single way of defining jobs: by implementing the IJob interface with a single RunAsync method: public class PrintHelloWorld : IJob { private readonly ILogger < PrintHelloWorld > logger ; public PrintHelloWorld ( ILogger < PrintHelloWorld > logger ) { this . logger = logger ; } public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { logger . LogInformation ( \"Hello World\" ); logger . LogInformation ( \"Parameter: {Parameter}\" , context . Parameter ); return Task . CompletedTask ; } }","title":"2. Create a job"},{"location":"getting-started/#3-register-the-service-and-the-job","text":"The NCronJob library provides one easy entry point for all its magic, the AddNCronJob extension method on top of the IServiceCollection interface. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { // Every minute and optional parameter j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); })); }); Now your PrintHelloWorld job will run every minute and log \u201cHello World\u201d to the console. And that is all!","title":"3. Register the service and the job"},{"location":"features/instant-jobs/","text":"Triggering instant jobs \u00b6 NCronJob allows you to trigger jobs instantly. This is useful when you want to run a job immediately without waiting for the next scheduled time. For example you get a API request and want to offload the work to a background job immediately. Instant jobs are like \u201cregular\u201d CRON jobs and inherit from IJob . The only difference is that they are triggered manually. So also CRON jobs can be triggered instantly. public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { ParameterDto dto = ( ParameterDto ) context . Parameter ; // Do something return Task . CompletedTask ; } } As CRON jobs, they have to be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyJob >(); // No need to specify a CRON expression }); There is no need of a CRON expression for instant jobs. Also passing in parameters doesn\u2019t do anything, they will be passed in differently. Let\u2019s have a look at how to trigger an instant job. Imagine we have a Minimal API where we want to send an E-Mail: app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob < MyJob >( parameterDto ); return Results . Ok (); }); The RunInstantJob method takes the job type and the parameters as arguments. Optionally you can pass in a CancellationToken as well. The job will be executed immediately. Starting a job with a delay \u00b6 If you find the need of delaying the execution of an instant job, you can use the RunScheduledJob method with a TimeSpan as a delay. The same as RunInstantJob applies here, the job has to be registered in the AddNCronJob method. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( TimeSpan . FromMinutes ( 5 ), parameterDto ); return Results . Ok (); }); Starting a job at a specific date and time \u00b6 If you want to start a job at a specific date and time, you can use the RunScheduledJob method with a DateTimeOffset as a parameter. The same as before: The job has to be registered. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( new DateTimeOffset ( 2024 , 1 , 1 , 0 , 0 , 0 , TimeSpan . FromHours ( 2 )), parameterDto ); return Results . Ok (); });","title":"Triggering instant jobs"},{"location":"features/instant-jobs/#triggering-instant-jobs","text":"NCronJob allows you to trigger jobs instantly. This is useful when you want to run a job immediately without waiting for the next scheduled time. For example you get a API request and want to offload the work to a background job immediately. Instant jobs are like \u201cregular\u201d CRON jobs and inherit from IJob . The only difference is that they are triggered manually. So also CRON jobs can be triggered instantly. public class MyJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { ParameterDto dto = ( ParameterDto ) context . Parameter ; // Do something return Task . CompletedTask ; } } As CRON jobs, they have to be registered in the AddNCronJob method. Services . AddNCronJob ( options => { options . AddJob < MyJob >(); // No need to specify a CRON expression }); There is no need of a CRON expression for instant jobs. Also passing in parameters doesn\u2019t do anything, they will be passed in differently. Let\u2019s have a look at how to trigger an instant job. Imagine we have a Minimal API where we want to send an E-Mail: app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunInstantJob < MyJob >( parameterDto ); return Results . Ok (); }); The RunInstantJob method takes the job type and the parameters as arguments. Optionally you can pass in a CancellationToken as well. The job will be executed immediately.","title":"Triggering instant jobs"},{"location":"features/instant-jobs/#starting-a-job-with-a-delay","text":"If you find the need of delaying the execution of an instant job, you can use the RunScheduledJob method with a TimeSpan as a delay. The same as RunInstantJob applies here, the job has to be registered in the AddNCronJob method. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( TimeSpan . FromMinutes ( 5 ), parameterDto ); return Results . Ok (); });","title":"Starting a job with a delay"},{"location":"features/instant-jobs/#starting-a-job-at-a-specific-date-and-time","text":"If you want to start a job at a specific date and time, you can use the RunScheduledJob method with a DateTimeOffset as a parameter. The same as before: The job has to be registered. app . MapPost ( \"/send-email\" , ( RequestDto dto , IInstantJobRegistry jobRegistry ) => { var parameterDto = new ParameterDto { Email = dto . Email , Subject = dto . Subject , Body = dto . Body }; jobRegistry . RunScheduledJob < MyJob >( new DateTimeOffset ( 2024 , 1 , 1 , 0 , 0 , 0 , TimeSpan . FromHours ( 2 )), parameterDto ); return Results . Ok (); });","title":"Starting a job at a specific date and time"},{"location":"features/multiple-cron-expressions/","text":"Registering multiple CRON expressions \u00b6 The flient builder allows you to register multiple CRON expressions for a single job. This is useful when you want to run a job at different times of the day. For example: Services . AddNCronJob ( options => { // Register a job that runs at midnight and midday options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"0 0 * * *\" ) // Run at midnight . And . WithCronExpression ( \"0 12 * * *\" ); // Run at midday }); }); The And method is used to chain multiple CRON expressions together. You can chain as many expressions as you like. If a given job has the same CRON expression registered multiple times, it will be executed multiple times as well. Services . AddNCronJob ( options => { // Register a job that runs every 5 minutes options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ) // Run every 5 minutes . And . WithCronExpression ( \"*/5 * * * *\" ); // Run every 5 minutes }); }); Two instances of the ExampleJob class will be created and executed every 5 minutes.","title":"Registering multiple CRON expressions"},{"location":"features/multiple-cron-expressions/#registering-multiple-cron-expressions","text":"The flient builder allows you to register multiple CRON expressions for a single job. This is useful when you want to run a job at different times of the day. For example: Services . AddNCronJob ( options => { // Register a job that runs at midnight and midday options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"0 0 * * *\" ) // Run at midnight . And . WithCronExpression ( \"0 12 * * *\" ); // Run at midday }); }); The And method is used to chain multiple CRON expressions together. You can chain as many expressions as you like. If a given job has the same CRON expression registered multiple times, it will be executed multiple times as well. Services . AddNCronJob ( options => { // Register a job that runs every 5 minutes options . AddJob < ExampleJob >( j => { j . WithCronExpression ( \"*/5 * * * *\" ) // Run every 5 minutes . And . WithCronExpression ( \"*/5 * * * *\" ); // Run every 5 minutes }); }); Two instances of the ExampleJob class will be created and executed every 5 minutes.","title":"Registering multiple CRON expressions"},{"location":"features/parameters/","text":"Passing parameters to a job \u00b6 Often times a job needs some kind of configuration or parameter to run. Imagine you have a job that generates a report and can run daily, weekly or monthly. You could create three different jobs for each frequency, but that would be a lot of duplicated code. Instead, you can pass in parameters to the job. Services . AddNCronJob ( options => { options . AddJob < ReportJob >( j => { // Runs every day at midnight and passes in the string \"daily\" j . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"daily\" ) . And . WithCronExpression ( \"0 0 * * 0\" ). WithParameter ( \"weekly\" ) . And . WithCronExpression ( \"0 0 1 * *\" ). WithParameter ( \"monthly\" ); }); }); In the ReportJob you can now access the parameter via the JobExecutionContext : public class ReportJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var parameter = context . Parameter ; // Do something with the parameter switch ( parameter ) { case \"daily\" : // Generate daily report break ; case \"weekly\" : // Generate weekly report break ; case \"monthly\" : // Generate monthly report break ; } return Task . CompletedTask ; } }","title":"Passing Parameters"},{"location":"features/parameters/#passing-parameters-to-a-job","text":"Often times a job needs some kind of configuration or parameter to run. Imagine you have a job that generates a report and can run daily, weekly or monthly. You could create three different jobs for each frequency, but that would be a lot of duplicated code. Instead, you can pass in parameters to the job. Services . AddNCronJob ( options => { options . AddJob < ReportJob >( j => { // Runs every day at midnight and passes in the string \"daily\" j . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"daily\" ) . And . WithCronExpression ( \"0 0 * * 0\" ). WithParameter ( \"weekly\" ) . And . WithCronExpression ( \"0 0 1 * *\" ). WithParameter ( \"monthly\" ); }); }); In the ReportJob you can now access the parameter via the JobExecutionContext : public class ReportJob : IJob { public Task RunAsync ( JobExecutionContext context , CancellationToken token ) { var parameter = context . Parameter ; // Do something with the parameter switch ( parameter ) { case \"daily\" : // Generate daily report break ; case \"weekly\" : // Generate weekly report break ; case \"monthly\" : // Generate monthly report break ; } return Task . CompletedTask ; } }","title":"Passing parameters to a job"},{"location":"migration/v2/","text":"v2 Migration Guide \u00b6 This document will describe the changes made in v2 of NCronJob and how to migrate from v1 . Version 2 of NCronJob brings some breaking changes to mae a better API. CronExpression moved towards builder \u00b6 In v1 one would define as such: services . AddNCronJob (); services . AddCronJob < PrintHelloWorld >( options => { options . CronExpression = \"* * * * *\" ; options . Parameter = \"Hello World\" ; }); With v2 the CronExpression is moved towards the builder pattern and AddCronJob is merged into AddNCronJob : Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }); }); This allows to easily define multiple jobs without adding much boilerplate code. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( p => p . WithCronExpression ( \"0 * * * *\" ). WithParameter ( \"Foo\" ) . And . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"Bar\" )); });","title":"v2 Migration Guide"},{"location":"migration/v2/#v2-migration-guide","text":"This document will describe the changes made in v2 of NCronJob and how to migrate from v1 . Version 2 of NCronJob brings some breaking changes to mae a better API.","title":"v2 Migration Guide"},{"location":"migration/v2/#cronexpression-moved-towards-builder","text":"In v1 one would define as such: services . AddNCronJob (); services . AddCronJob < PrintHelloWorld >( options => { options . CronExpression = \"* * * * *\" ; options . Parameter = \"Hello World\" ; }); With v2 the CronExpression is moved towards the builder pattern and AddCronJob is merged into AddNCronJob : Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( j => { j . WithCronExpression ( \"* * * * *\" ) . WithParameter ( \"Hello World\" ); }); }); This allows to easily define multiple jobs without adding much boilerplate code. Services . AddNCronJob ( options => { options . AddJob < PrintHelloWorld >( p => p . WithCronExpression ( \"0 * * * *\" ). WithParameter ( \"Foo\" ) . And . WithCronExpression ( \"0 0 * * *\" ). WithParameter ( \"Bar\" )); });","title":"CronExpression moved towards builder"}]}